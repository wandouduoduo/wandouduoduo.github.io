<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>豌豆多多</title>
  
  <subtitle>Deveops Study Notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wandouduoduo.github.io/"/>
  <updated>2019-08-07T02:06:43.496Z</updated>
  <id>http://wandouduoduo.github.io/</id>
  
  <author>
    <name>WanDouDuoDuo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker安装Confluence(破解版)</title>
    <link href="http://wandouduoduo.github.io/articles/f9f96949.html"/>
    <id>http://wandouduoduo.github.io/articles/f9f96949.html</id>
    <published>2019-07-30T10:17:29.000Z</published>
    <updated>2019-08-07T02:06:43.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>confluence是一个专业的企业知识管理与协同软件，可以用于构建企业wiki。通过它可以实现团队成员之间的协作和知识共享。现在大多数公司都会部署一套confluence，用作内部wiki。现在confluence已收费，那么下面将介绍下Docker安装破解confluence的操作记录。</p><a id="more"></a><h2 id="环境版本"><a href="#环境版本" class="headerlink" title="环境版本"></a>环境版本</h2><p>Docker ：17.12.0-ce</p><p>MySQL：5.7</p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>Docker安装MySQL详见<a href="https://my.oschina.net/u/2289161/blog/1647061" target="_blank" rel="noopener">https://my.oschina.net/u/2289161/blog/1647061</a></p><h2 id="安装Confluence"><a href="#安装Confluence" class="headerlink" title="安装Confluence"></a>安装Confluence</h2><p>下载镜像：<a href="https://hub.docker.com/r/cptactionhank/atlassian-confluence/" target="_blank" rel="noopener">https://hub.docker.com/r/cptactionhank/atlassian-confluence/</a></p><p>启动一个confluence容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name confluence -p 8090:8090  --link mysql5.7:db --user root:root cptactionhank/atlassian-confluence:latest</span><br></pre></td></tr></table></figure><p>可以用以下命令检查confluence是否启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps  </span><br><span class="line">docker inspect confluence</span><br></pre></td></tr></table></figure><p>访问<a href="http://host-to-server:8090/" target="_blank" rel="noopener">http://ip:8090/</a> 就可以看到Confluence的初始化和配置页面。</p><p><img src="/articles/f9f96949/1.png" alt="img"></p><p>选择中文。</p><p><img src="/articles/f9f96949/2.png" alt="img"></p><p>选择产品安装并点击下一步，继续安装。</p><p><img src="/articles/f9f96949/3.png" alt="img"></p><p><img src="/articles/f9f96949/4.png" alt="img"></p><p><strong>通过上图可以看出需要输入授权码，下面介绍下破解confluence授权码的操作。</strong></p><h2 id="破解confluence"><a href="#破解confluence" class="headerlink" title="破解confluence"></a><strong>破解confluence</strong></h2><p>下载破解confluence文件：</p><p>atlassian-universal-plugin-manager-plugin-2.22.jar</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://cdn-blog.oss-cn-beijing.aliyuncs.com/k2p-frp/atlassian-universal-plugin-manager-plugin-2.22.jar</span><br></pre></td></tr></table></figure><p>atlassian-extras-decoder-v2-3.2.jar</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://cdn-blog.oss-cn-beijing.aliyuncs.com/k2p-frp/atlassian-extras-decoder-v2-3.2.jar</span><br></pre></td></tr></table></figure><p>进入confluence容器命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it confluence /bin/sh</span><br></pre></td></tr></table></figure><p>用下载的文件替换atlassian-extras-decoder-v2-3.x.jar/atlassian-universal-plugin-manager-plugin-2.22.x.jar文件（该文件下载到<code>/opt``下，替换前必须做之前的文件备份，方便回退）</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">备份要替换的文件</span></span><br><span class="line">mv /opt/atlassian/confluence/confluence/WEB-INF/lib/atlassian-extras-decoder-v2-3.3.0.jar   /mnt/</span><br><span class="line">mv /opt/atlassian/confluence/confluence/WEB-INF/atlassian-bundled-plugins/atlassian-universal-plugin-manager-plugin-2.22.5.jar /mnt</span><br></pre></td></tr></table></figure><p>备份好文件后，退出confluence容器。拷贝下载的文件到confluence容器中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将下载的破解文件替换对应的jar</span></span><br><span class="line">docker cp atlassian-extras-decoder-v2-3.2.jar confluence:/opt/atlassian/confluence/confluence/WEB-INF/lib/</span><br><span class="line">docker cp atlassian-universal-plugin-manager-plugin-2.22.jar  confluence:/opt/atlassian/confluence/confluence/WEB-INF/atlassian-bundled-plugins/</span><br></pre></td></tr></table></figure><p>重新启动confluence容器。</p><p>然后继续访问<a href="http://172.16.220.129:8090/" target="_blank" rel="noopener">http://ip:8090</a>，接着注册confluence的key</p><p><img src="/articles/f9f96949/5.png" alt="img"></p><p>下面的操作需要在翻墙的前提下进行，使用google邮箱注册。</p><p><img src="/articles/f9f96949/6.png" alt="img"></p><p><img src="/articles/f9f96949/7.png" alt="img"></p><p><img src="/articles/f9f96949/8.png" alt="img"></p><p><img src="/articles/f9f96949/9.png" alt="img"></p><p><img src="/articles/f9f96949/10.png" alt="img"></p><p><img src="/articles/f9f96949/11.png" alt="img"></p><p><img src="/articles/f9f96949/12.png" alt="img"></p><p><strong>稍微等一会儿，就会自动弹出下面的信息，点击”Yes”</strong></p><p><img src="/articles/f9f96949/13.png" alt="img"></p><p><img src="/articles/f9f96949/14.png" alt="img"></p><p><img src="/articles/f9f96949/15.png" alt="img"></p><p><img src="/articles/f9f96949/16.png" alt="img"></p><p>再连接数据库时，需要修改数据库的隔离级别。操作详见：<a href="https://blog.csdn.net/taylor_tao/article/details/7063639" target="_blank" rel="noopener">https://blog.csdn.net/taylor_tao/article/details/7063639</a></p><p><img src="/articles/f9f96949/17.png" alt="img"></p><p><img src="/articles/f9f96949/18.png" alt="img"></p><p><img src="/articles/f9f96949/19.png" alt="img"></p><p><img src="/articles/f9f96949/20.png" alt="img"></p><p><img src="/articles/f9f96949/21.png" alt="img"></p><p><img src="/articles/f9f96949/22.png" alt="img"></p><p><img src="/articles/f9f96949/23.png" alt="img"></p><p><img src="/articles/f9f96949/24.png" alt="img"></p><p><img src="/articles/f9f96949/25.png" alt="img"></p><p><strong>下面说下confluence邮箱功能（不多赘述，直接看截图）：</strong></p><p><strong><img src="/articles/f9f96949/26.jpg" alt="img"></strong></p><p><strong><img src="/articles/f9f96949/27.jpg" alt="img"></strong></p><p><strong><img src="/articles/f9f96949/28.jpg" alt="img"></strong></p><p><strong><img src="/articles/f9f96949/29.jpg" alt="img"></strong></p><p><strong><img src="/articles/f9f96949/30.jpg" alt="img"></strong></p><p><strong><img src="/articles/f9f96949/31.jpg" alt="img"></strong></p><p><strong><img src="/articles/f9f96949/32.jpg" alt="img"></strong></p><p><img src="/articles/f9f96949/33.jpg" alt="img"></p><p><strong>有上面配置后，就已经配置好了confluence的邮件功能了。下面说下在管理员账号下创建或邀请其他用户的做法：</strong></p><p><strong><img src="/articles/f9f96949/34.jpg" alt="img"></strong></p><p><strong>一般要禁止用户注册自己注册，要在管理员账号下创建新用户或邀请新用户（通过邮件的方式）</strong></p><p><strong><img src="/articles/f9f96949/35.jpg" alt="img"></strong></p><p><strong>如下在管理员账号下”添加用户”,添加后给用户设置一个初始密码，用户收到邮件后，可以登陆修改密码。</strong></p><p><strong><img src="/articles/f9f96949/36.jpg" alt="img"></strong></p><p><strong><img src="/articles/f9f96949/37.jpg" alt="img"></strong></p><p><strong>———————————————————————————————————–</strong><br><strong>也可以通过”邀请用户”的方式来创建新用户，用户收到邮件后，按照邮件提示进行用户创建</strong></p><p><strong><img src="/articles/f9f96949/38.jpg" alt="img"></strong></p><p><strong>———————————————————————————————————–</strong><br><strong>邮件功能设置后，在分享文章的时候，可以以邮件的方式分享到用户的邮箱里。</strong></p><p><img src="/articles/f9f96949/39.jpg" alt="img"></p><p>注意：在创建文章时 ，左边的页面或子页面的创建时，可以点击左下角的”空间管理”-“配置侧边栏”<br><strong>到此，confluence的安装破解已经完全搞定！后续再介绍下confluence跟jira接连、及其它们对接LDAP的做法！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;confluence是一个专业的企业知识管理与协同软件，可以用于构建企业wiki。通过它可以实现团队成员之间的协作和知识共享。现在大多数公司都会部署一套confluence，用作内部wiki。现在confluence已收费，那么下面将介绍下Docker安装破解confluence的操作记录。&lt;/p&gt;
    
    </summary>
    
      <category term="应用运维" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Docker" scheme="http://wandouduoduo.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Redis-cluster集群[四]:redis-cluster集群配置</title>
    <link href="http://wandouduoduo.github.io/articles/d2e62a87.html"/>
    <id>http://wandouduoduo.github.io/articles/d2e62a87.html</id>
    <published>2019-07-30T10:01:08.000Z</published>
    <updated>2019-08-07T02:06:43.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis分片："><a href="#Redis分片：" class="headerlink" title="Redis分片："></a>Redis分片：</h2><p>为什么要分片：随着Redis存储的数据越来越庞大，会导致Redis的性能越来越差！</p><p>目前分片的方法：</p><p>1,客户端分片</p><p>在应用层面分片，程序里指定什么数据存放在那个Redis  优势：比较灵活    缺点：加个节点扩容就很费劲</p><p>2, 代理Proxy分片  第三方的Twemproxy  使用代理的缺点，你代理什么性能，那么你整个Redis的性能就是什么样的！</p><p>3, redis cluster</p><p>4, codis （豌豆荚）开源</p> <a id="more"></a><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://redisdoc.com/topic/cluster-tutorial.html#id2" target="_blank" rel="noopener">Redis cluster</a></p><h2 id="集群分片原理："><a href="#集群分片原理：" class="headerlink" title="集群分片原理："></a>集群分片原理：</h2><p>Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现： 一个 Redis 集群包含 16384 个哈希槽（hash slot），</p><p>数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽，</p><p>其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p><p>集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个哈希槽， 其中：</p><pre><code>* 节点 A 负责处理 0 号至 5500 号哈希槽。* 节点 B 负责处理 5501 号至 11000 号哈希槽。* 节点 C 负责处理 11001 号至 16384 号哈希槽。</code></pre><p>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：</p><pre><code>* 如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。* 与此类似， 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。</code></pre><p>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。</p><p>Redis集群中的主从复制<br>为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作，</p><p>Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。<br>在之前列举的节点 A 、B 、C 的例子中， 如果节点 B 下线了， 那么集群将无法正常运行， 因为集群找不到节点来处理 5501 号至 11000 号的哈希槽。<br>另一方面， 假如在创建集群的时候（或者至少在节点 B 下线之前）， 我们为主节点 B 添加了从节点 B1 ， 那么当主节点 B 下线的时候， 集群就会将 B1 设置为新的主节点，</p><p>并让它代替下线的主节点 B ， 继续处理 5501 号至 11000 号的哈希槽， 这样集群就不会因为主节点 B 的下线而无法正常运作了。</p><p>不过如果节点 B 和 B1 都下线的话， Redis 集群还是会停止运作。</p><p>Redis 集群的一致性保证（guarantee）<br>Redis 集群不保证数据的强一致性（strong consistency）： 在特定条件下， Redis 集群可能会丢失已经被执行过的写命令。<br>使用异步复制（asynchronous replication）是 Redis 集群可能会丢失写命令的其中一个原因。 考虑以下这个写命令的例子：</p><pre><code>* 客户端向主节点 B 发送一条写命令。* 主节点 B 执行写命令，并向客户端返回命令回复。* 主节点 B 将刚刚执行的写命令复制给它的从节点 B1 、 B2 和 B3 。</code></pre><p>如你所见， 主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。<br>如果真的有必要的话， Redis 集群可能会在将来提供同步地（synchronou）执行写命令的方法。<br>Redis 集群另外一种可能会丢失命令的情况是， 集群出现网络分裂（network partition）， 并且一个客户端与至少包括一个主节点在内的少数（minority）实例被孤立。<br>举个例子， 假设集群包含 A 、 B 、 C 、 A1 、 B1 、 C1 六个节点， 其中 A 、B 、C 为主节点， 而 A1 、B1 、C1 分别为三个主节点的从节点， 另外还有一个客户端 Z1 。<br>假设集群中发生网络分裂， 那么集群可能会分裂为两方， 大多数（majority）的一方包含节点 A 、C 、A1 、B1 和 C1 ， 而少数（minority）的一方则包含节点 B 和客户端 Z1 。<br>在网络分裂期间， 主节点 B 仍然会接受 Z1 发送的写命令：</p><pre><code>* 如果网络分裂出现的时间很短， 那么集群会继续正常运行；* 但是， 如果网络分裂出现的时间足够长， 使得大多数一方将从节点 B1 设置为新的主节点， 并使用 B1 来代替原来的主节点 B ， 那么 Z1 发送给主节点 B 的写命令将丢失。</code></pre><p>注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项：</p><ul><li><p>对于大多数一方来说， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么集群会将这个主节点视为下线， 并使用从节点来代替这个主节点继续工作。</p></li><li><p>对于少数一方， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么它将停止处理写命令， 并向客户端报告错误。</p></li></ul><h2 id="Redis-Cluster安装："><a href="#Redis-Cluster安装：" class="headerlink" title="Redis Cluster安装："></a>Redis Cluster安装：</h2><p>1、安装环境：首先确保安装了Redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/</span><br><span class="line">mkdir `seq 7001 7008`</span><br><span class="line">cp /etc/redis/6379.conf ./</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">配置文件里：</span><br><span class="line"> </span><br><span class="line">新增这三行即可</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"> </span><br><span class="line">并且报：AOF是开启的</span><br><span class="line">appendonly yes</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">把相关的信息都统一修改为：6379  （端口、日志文件、存储dir持久化）</span></span><br><span class="line">sed  's/6379/7001/g' 6379.conf &gt; 7001/redis.conf</span><br><span class="line">sed  's/6379/7002/g' 6379.conf &gt; 7002/redis.conf</span><br><span class="line">sed  's/6379/7003/g' 6379.conf &gt; 7003/redis.conf</span><br><span class="line">sed  's/6379/7004/g' 6379.conf &gt; 7004/redis.conf</span><br><span class="line">sed  's/6379/7005/g' 6379.conf &gt; 7005/redis.conf</span><br><span class="line">sed  's/6379/7006/g' 6379.conf &gt; 7006/redis.conf</span><br><span class="line">sed  's/6379/7007/g' 6379.conf &gt; 7007/redis.conf</span><br><span class="line">sed  's/6379/7008/g' 6379.conf &gt; 7008/redis.conf</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">for i in `seq 7001 7009`;do cd /opt/$i &amp;&amp; /usr/local/bin/redis-server redis.conf ; done</span><br></pre></td></tr></table></figure><p>2、安装管理工具，源码自带了一个管理Cluster集群的工具是用ruby写的所以需要安装ruby</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ruby rubygems</span><br><span class="line"><span class="meta">#</span><span class="bash">安装ruby的管理工具redis</span></span><br><span class="line">gem install redis</span><br></pre></td></tr></table></figure><p> 3、复制管理工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /opt/redis-3.0.4/src/redis-trib.rb /usr/local/bin/redis-trib</span><br><span class="line"><span class="meta">#</span><span class="bash">查看redis-trib帮助</span></span><br><span class="line">redis-trib help</span><br></pre></td></tr></table></figure><p> 4、创建集群  7001-7006   6个redis为集群node，7007-7008   “2个redis为back node”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">[root@server.tianshuai.com]$ redis-trib create --replicas 1 192.168.0.201:7001 192.168.0.201:7002 192.168.0.201:7003 192.168.0.201:7004 192.168.0.201:7005 192.168.0.201:7006</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Creating cluster</span></span><br><span class="line">Connecting to node 192.168.0.201:7001: OK</span><br><span class="line">Connecting to node 192.168.0.201:7002: OK</span><br><span class="line">Connecting to node 192.168.0.201:7003: OK</span><br><span class="line">Connecting to node 192.168.0.201:7004: OK</span><br><span class="line">Connecting to node 192.168.0.201:7005: OK</span><br><span class="line">Connecting to node 192.168.0.201:7006: OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span></span><br><span class="line">Using 3 masters:</span><br><span class="line">192.168.0.201:7001</span><br><span class="line">192.168.0.201:7002</span><br><span class="line">192.168.0.201:7003                                                                         </span><br><span class="line">Adding replica 192.168.0.201:7004 to 192.168.0.201:7001</span><br><span class="line">Adding replica 192.168.0.201:7005 to 192.168.0.201:7002</span><br><span class="line">Adding replica 192.168.0.201:7006 to 192.168.0.201:7003</span><br><span class="line">M: 699f318027f87f3c49d48e44116820e673bd306a 192.168.0.201:7001                          </span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">M: 96892fd3f51292e922383ddb6e8018e2f772deed 192.168.0.201:7002</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">M: f702fd03c1e3643db7e385915842533ba5aab98d 192.168.0.201:7003</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">S: d0994ce7ef68c0834030334afcd60013773f2e77 192.168.0.201:7004                          </span><br><span class="line">   replicates 699f318027f87f3c49d48e44116820e673bd306a</span><br><span class="line">S: d880581504caff4a002242b2b259d5242b8569fc 192.168.0.201:7005</span><br><span class="line">   replicates 96892fd3f51292e922383ddb6e8018e2f772deed</span><br><span class="line">S: a77b16c4f140c0f5c17c907ce7ee5e42ee2a7b02 192.168.0.201:7006</span><br><span class="line">   replicates f702fd03c1e3643db7e385915842533ba5aab98d</span><br><span class="line">Can I set the above configuration? (type 'yes' to accept):  YES</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Nodes configuration updated</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Assign a different config epoch to each node</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span></span><br><span class="line">Waiting for the cluster to join...</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 192.168.0.201:7001)</span></span><br><span class="line">M: 699f318027f87f3c49d48e44116820e673bd306a 192.168.0.201:7001</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">M: 96892fd3f51292e922383ddb6e8018e2f772deed 192.168.0.201:7002</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">M: f702fd03c1e3643db7e385915842533ba5aab98d 192.168.0.201:7003</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">M: d0994ce7ef68c0834030334afcd60013773f2e77 192.168.0.201:7004</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">   replicates 699f318027f87f3c49d48e44116820e673bd306a</span><br><span class="line">M: d880581504caff4a002242b2b259d5242b8569fc 192.168.0.201:7005</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">   replicates 96892fd3f51292e922383ddb6e8018e2f772deed</span><br><span class="line">M: a77b16c4f140c0f5c17c907ce7ee5e42ee2a7b02 192.168.0.201:7006</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">   replicates f702fd03c1e3643db7e385915842533ba5aab98d</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">create --replicas 1    这里--replicas 1 是指定复制几份，相当于每个master有几个从</span></span><br><span class="line"><span class="meta">#</span><span class="bash">redis cluaster最低要求有3个master</span></span><br><span class="line"><span class="meta">#</span><span class="bash">master的定义  host1:port host2:port  host3:port如果--replicas 1 那么：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">host1:port == master  host2:port 是：host1:port从</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">如果--replicas 2 那么：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">host1:port == master host2:port &amp; host3:port 是host1:port 的从</span></span><br><span class="line"> </span><br><span class="line">M: 这个是cluaster 自动生成的ID 集群在通信的时候是使用这个ID来区分的</span><br></pre></td></tr></table></figure><p> 4、连接cluster（连接任意的Cluster集群中的服务器即可）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -h 192.168.0.201 -p 7001   的需要加-c的参数   可以连接集群的任意节点！</span><br><span class="line"> </span><br><span class="line">192.168.0.201:7001&gt; cluster nodes  查看cluster节点</span><br><span class="line">f702fd03c1e3643db7e385915842533ba5aab98d 192.168.0.201:7003 master - 0 1444813870405 3 connected 10923-16383</span><br><span class="line">699f318027f87f3c49d48e44116820e673bd306a 192.168.0.201:7001 myself,master - 0 0 1 connected 0-5460</span><br><span class="line">d0994ce7ef68c0834030334afcd60013773f2e77 192.168.0.201:7004 slave 699f318027f87f3c49d48e44116820e673bd306a 0 1444813870105 4 connected</span><br><span class="line">a77b16c4f140c0f5c17c907ce7ee5e42ee2a7b02 192.168.0.201:7006 slave f702fd03c1e3643db7e385915842533ba5aab98d 0 1444813868605 6 connected</span><br><span class="line">96892fd3f51292e922383ddb6e8018e2f772deed 192.168.0.201:7002 master - 0 1444813869405 2 connected 5461-10922</span><br><span class="line">d880581504caff4a002242b2b259d5242b8569fc 192.168.0.201:7005 slave 96892fd3f51292e922383ddb6e8018e2f772deed 0 1444813869105 5 connected</span><br><span class="line"> </span><br><span class="line">192.168.0.201:7001&gt; cluster info  查看cluster信息</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_sent:1809</span><br><span class="line">cluster_stats_messages_received:1809</span><br></pre></td></tr></table></figure><p>5、集群扩容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">redis-trib add-node 192.168.0.201:7007 192.168.0.201:7001 </span><br><span class="line">命令解释：</span><br><span class="line">redis-trib add-node 要加的节点和端口  现有任意节点和端口</span><br><span class="line"> </span><br><span class="line">加完之后查看结果：</span><br><span class="line">192.168.0.201:7001&gt; cluster info</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:7</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_sent:2503</span><br><span class="line">cluster_stats_messages_received:2503</span><br><span class="line">192.168.0.201:7001&gt; cluster nodes</span><br><span class="line">f702fd03c1e3643db7e385915842533ba5aab98d 192.168.0.201:7003 master - 0 1444814061587 3 connected 10923-16383</span><br><span class="line">699f318027f87f3c49d48e44116820e673bd306a 192.168.0.201:7001 myself,master - 0 0 1 connected 0-5460</span><br><span class="line">d0994ce7ef68c0834030334afcd60013773f2e77 192.168.0.201:7004 slave 699f318027f87f3c49d48e44116820e673bd306a 0 1444814062087 4 connected</span><br><span class="line">a77b16c4f140c0f5c17c907ce7ee5e42ee2a7b02 192.168.0.201:7006 slave f702fd03c1e3643db7e385915842533ba5aab98d 0 1444814061087 6 connected</span><br><span class="line">a1301a9e1fd24099cd8dc49c47f2263e3124e4d6 192.168.0.201:7007 master - 0 1444814063089 0 connected</span><br><span class="line">96892fd3f51292e922383ddb6e8018e2f772deed 192.168.0.201:7002 master - 0 1444814062589 2 connected 5461-10922</span><br><span class="line">d880581504caff4a002242b2b259d5242b8569fc 192.168.0.201:7005 slave 96892fd3f51292e922383ddb6e8018e2f772deed 0 1444814061587 5 connected</span><br><span class="line">192.168.0.201:7001&gt;</span><br></pre></td></tr></table></figure><p> 6、新加上来没有数据-及没有槽位，我们可以用命令让他重新分片（分片）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib reshard 192.168.0.201:7007</span><br></pre></td></tr></table></figure><p> 7、在添加一个服务器做从</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">在添加一个7008 让他做7008的从</span><br><span class="line">[root@server.tianshuai.com]$ redis-trib add-node 192.168.0.201:7008 192.168.0.201:7001</span><br><span class="line">加进来之后默认就是mater但是他没有任何的槽位</span><br><span class="line">192.168.0.201:7001&gt; cluster nodes</span><br><span class="line">f702fd03c1e3643db7e385915842533ba5aab98d 192.168.0.201:7003 master - 0 1444814915795 3 connected 11089-16383</span><br><span class="line">699f318027f87f3c49d48e44116820e673bd306a 192.168.0.201:7001 myself,master - 0 0 1 connected 166-5460</span><br><span class="line">d0994ce7ef68c0834030334afcd60013773f2e77 192.168.0.201:7004 slave 699f318027f87f3c49d48e44116820e673bd306a 0 1444814917298 4 connected</span><br><span class="line">a77b16c4f140c0f5c17c907ce7ee5e42ee2a7b02 192.168.0.201:7006 slave f702fd03c1e3643db7e385915842533ba5aab98d 0 1444814916297 6 connected</span><br><span class="line">a02a66e0286ee2f0a9b5380f7584b9b20dc032ff 192.168.0.201:7008 master - 0 1444814915796 0 connected</span><br><span class="line">a1301a9e1fd24099cd8dc49c47f2263e3124e4d6 192.168.0.201:7007 master - 0 1444814915295 7 connected 0-165 5461-5627 10923-11088</span><br><span class="line">96892fd3f51292e922383ddb6e8018e2f772deed 192.168.0.201:7002 master - 0 1444814916898 2 connected 5628-10922</span><br><span class="line">d880581504caff4a002242b2b259d5242b8569fc 192.168.0.201:7005 slave 96892fd3f51292e922383ddb6e8018e2f772deed 0 1444814916798 5 connected</span><br><span class="line"> </span><br><span class="line">然后连接到7008的这个redis实例上，然后复制7007的ID</span><br><span class="line">192.168.0.201:7008&gt; cluster replicate a1301a9e1fd24099cd8dc49c47f2263e3124e4d6</span><br><span class="line">OK</span><br><span class="line">然后看下：</span><br><span class="line">192.168.0.201:7008&gt; cluster nodes</span><br><span class="line">699f318027f87f3c49d48e44116820e673bd306a 192.168.0.201:7001 master - 0 1444815074072 1 connected 166-5460</span><br><span class="line">a1301a9e1fd24099cd8dc49c47f2263e3124e4d6 192.168.0.201:7007 master - 0 1444815073071 7 connected 0-165 5461-5627 10923-11088</span><br><span class="line">96892fd3f51292e922383ddb6e8018e2f772deed 192.168.0.201:7002 master - 0 1444815073671 2 connected 5628-10922</span><br><span class="line">a77b16c4f140c0f5c17c907ce7ee5e42ee2a7b02 192.168.0.201:7006 slave f702fd03c1e3643db7e385915842533ba5aab98d 0 1444815073571 3 connected</span><br><span class="line">f702fd03c1e3643db7e385915842533ba5aab98d 192.168.0.201:7003 master - 0 1444815072571 3 connected 11089-16383</span><br><span class="line">d0994ce7ef68c0834030334afcd60013773f2e77 192.168.0.201:7004 slave 699f318027f87f3c49d48e44116820e673bd306a 0 1444815073071 1 connected</span><br><span class="line">d880581504caff4a002242b2b259d5242b8569fc 192.168.0.201:7005 slave 96892fd3f51292e922383ddb6e8018e2f772deed 0 1444815073871 2 connected</span><br><span class="line">a02a66e0286ee2f0a9b5380f7584b9b20dc032ff 192.168.0.201:7008 myself,slave a1301a9e1fd24099cd8dc49c47f2263e3124e4d6 0 0 0 connected</span><br><span class="line">192.168.0.201:7008&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">192.168.7.107:7002&gt; set key101 shuaige</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [1601] located at 192.168.7.107:7001</span></span><br><span class="line">OK</span><br><span class="line">192.168.7.107:7001&gt; set key102 shuaige</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [13858] located at 192.168.7.107:7003</span></span><br><span class="line">OK</span><br><span class="line">192.168.7.107:7003&gt; set key103 shuaige</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [9731] located at 192.168.7.107:7002</span></span><br><span class="line">OK</span><br><span class="line">192.168.7.107:7002&gt; set key104 shuaige</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [5860] located at 192.168.7.107:7007</span></span><br><span class="line">OK</span><br><span class="line">192.168.7.107:7007&gt; set key105 shuaige</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [1733] located at 192.168.7.107:7001</span></span><br><span class="line">OK</span><br><span class="line">192.168.7.107:7001&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis分片：&quot;&gt;&lt;a href=&quot;#Redis分片：&quot; class=&quot;headerlink&quot; title=&quot;Redis分片：&quot;&gt;&lt;/a&gt;Redis分片：&lt;/h2&gt;&lt;p&gt;为什么要分片：随着Redis存储的数据越来越庞大，会导致Redis的性能越来越差！&lt;/p&gt;
&lt;p&gt;目前分片的方法：&lt;/p&gt;
&lt;p&gt;1,客户端分片&lt;/p&gt;
&lt;p&gt;在应用层面分片，程序里指定什么数据存放在那个Redis  优势：比较灵活    缺点：加个节点扩容就很费劲&lt;/p&gt;
&lt;p&gt;2, 代理Proxy分片  第三方的Twemproxy  使用代理的缺点，你代理什么性能，那么你整个Redis的性能就是什么样的！&lt;/p&gt;
&lt;p&gt;3, redis cluster&lt;/p&gt;
&lt;p&gt;4, codis （豌豆荚）开源&lt;/p&gt;
    
    </summary>
    
      <category term="数据库运维" scheme="http://wandouduoduo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Redis" scheme="http://wandouduoduo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-cluster集群[三]:redis主从复制</title>
    <link href="http://wandouduoduo.github.io/articles/1e52f2e4.html"/>
    <id>http://wandouduoduo.github.io/articles/1e52f2e4.html</id>
    <published>2019-07-30T09:54:51.000Z</published>
    <updated>2019-08-07T02:06:43.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis主从复制原理："><a href="#Redis主从复制原理：" class="headerlink" title="Redis主从复制原理："></a>Redis主从复制原理：</h2><p>通过把这个RDB文件或AOF文件传给slave服务器，slave服务器重新加载RDB文件，来实现复制的功能！</p><p>复制的话：主服务器可以有多个从服务器！！！  不仅这样从服务器还可以有从服务器，可以做成星状的结构！</p><p>复制的话也不会阻塞进程，同样fork一个子进程来做！</p><p>复制的原理：</p><p>当建立一个从服务器后，从服务器会想主服务器发送一个SYNC的命令，主服务器接收到SYNC命令之后会执行BGSAVE</p><p>然后保存到RDB文件，然后发送到从服务器！收到RDB文件然后就载入到内存！</p><p>最早不支持增量，到2.8之后就支持增量了！</p><a id="more"></a><h2 id="Redis主从配置："><a href="#Redis主从配置：" class="headerlink" title="Redis主从配置："></a>Redis主从配置：</h2><p>配置非常简单：</p><p>我要把：192.168.0.201  6380 作为192.168.0.201 6379的从就一条命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.201:6380&gt; slaveof 192.168.0.201 6379</span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">然后使用INFO查看下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:192.168.0.201</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:7</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:85</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">然后在到主的上面看下：</span></span><br><span class="line">15:38 [root@server.tianshuai.com]$ redis-cli -h 192.168.0.201 -p 6379</span><br><span class="line">192.168.0.201:6379&gt; INFO</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=192.168.0.201,port=6380,state=online,offset=183,lag=1    #</span><br><span class="line">master_repl_offset:183</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:182</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">从2.61 的时候！从是仅读的</span></span><br><span class="line">192.168.0.201:6380&gt; SET key1 2</span><br><span class="line">(error) READONLY You can't write against a read only slave.</span><br><span class="line">192.168.0.201:6380&gt;&lt;br&gt;##现实工作场景中，写和读是1：10的吗，我们就可以，设置多1个主多个从这样，进行读写分离！</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis主从复制原理：&quot;&gt;&lt;a href=&quot;#Redis主从复制原理：&quot; class=&quot;headerlink&quot; title=&quot;Redis主从复制原理：&quot;&gt;&lt;/a&gt;Redis主从复制原理：&lt;/h2&gt;&lt;p&gt;通过把这个RDB文件或AOF文件传给slave服务器，slave服务器重新加载RDB文件，来实现复制的功能！&lt;/p&gt;
&lt;p&gt;复制的话：主服务器可以有多个从服务器！！！  不仅这样从服务器还可以有从服务器，可以做成星状的结构！&lt;/p&gt;
&lt;p&gt;复制的话也不会阻塞进程，同样fork一个子进程来做！&lt;/p&gt;
&lt;p&gt;复制的原理：&lt;/p&gt;
&lt;p&gt;当建立一个从服务器后，从服务器会想主服务器发送一个SYNC的命令，主服务器接收到SYNC命令之后会执行BGSAVE&lt;/p&gt;
&lt;p&gt;然后保存到RDB文件，然后发送到从服务器！收到RDB文件然后就载入到内存！&lt;/p&gt;
&lt;p&gt;最早不支持增量，到2.8之后就支持增量了！&lt;/p&gt;
    
    </summary>
    
      <category term="数据库运维" scheme="http://wandouduoduo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Redis" scheme="http://wandouduoduo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-cluster集群[二]:redis持久化</title>
    <link href="http://wandouduoduo.github.io/articles/8d5e3656.html"/>
    <id>http://wandouduoduo.github.io/articles/8d5e3656.html</id>
    <published>2019-07-30T07:14:21.000Z</published>
    <updated>2019-08-07T02:06:43.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis持久化原理："><a href="#Redis持久化原理：" class="headerlink" title="Redis持久化原理："></a>Redis持久化原理：</h2><p>Redis支持两种持久化：<strong>RDB</strong>和<strong>AOF</strong>模式</p><a id="more"></a><h4 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a><strong>名词解释：</strong></h4><p><strong>RDB</strong>：持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。<br><strong>AOF</strong>：持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。</p><p><strong>AOF</strong> 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite）</p><p>使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</p><p>PDB和AOF的优先级：</p><p>如果同时开启RDB和AOF模式，AOF的优先级要比RDB高：<br>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集。</p><p>因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</p><p>AOF 的方式有点像ORCAL的逻辑备库！<br>AOF redis 还会在后台对数据进行重写，比如set key1 ， set key1 ,其实第一次的set key1 没用，这样就可以把第一次set key1 删掉了。这样保存下来的数据集就很小了可以压缩了！<br>你甚至可以关闭持久化功能，让数据只在服务器运行时存在。</p><h4 id="RDB-amp-AOF优缺点"><a href="#RDB-amp-AOF优缺点" class="headerlink" title="RDB&amp;AOF优缺点"></a><strong>RDB&amp;AOF优缺点</strong></h4><p><strong>RDB</strong>的优缺点：<br>优点：<br>1、紧凑易于备份，他就一个文件。<br>2、RDB可以最大化redis性能、父进程无需做任何操作只需要for一个子进程即可<br>3、恢复比AOF块</p><p>缺点：<br>1、数据完整性：如果非常注重数据的完整性，那么RDB就不行，虽然他是一个point-in-time 的快照方式，但是在快照的过程中，redis重启了，那么在快照中的这些数据将会丢失<br>2、数据非常庞大后，非常耗CPU和时间，那么redis讲可能down掉1秒钟设置更长。</p><p><strong>AOF</strong>的优缺点：<br>优点：<br>1、 使用 AOF 持久化会让 Redis 变得非常耐久，AOF默认的每一秒追加一次也可以修改他的方式没执行一次命令追加一次，所以你最多丢失1秒钟的数据<br>2、 AOF 文件是一个只进行追加操作的日志文件（append only log）<br>3、 Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写</p><p>缺点：<br>1、对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。<br>2、 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB</p><h4 id="RDB-amp-AOF-持久化原理"><a href="#RDB-amp-AOF-持久化原理" class="headerlink" title="RDB &amp; AOF 持久化原理"></a><strong>RDB &amp; AOF 持久化原理</strong></h4><p>快照的运行方式：</p><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：</p><ol><li>Redis 调用 fork() ，同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li><li>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。</li></ol><p>AOF 重写和 RDB 创建快照一样，都巧妙地利用了写时复制机制。</p><p>以下是 AOF 重写的执行步骤：</p><ol><li>Redis 执行 fork() ，现在同时拥有父进程和子进程。</li><li>子进程开始将新 AOF 文件的内容写入到临时文件。</li><li>对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾： 这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。</li><li>当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。</li><li>搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</li></ol><p>AOF重写</p><p>因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。<br>举个例子， 如果你对一个计数器调用了 100 次 INCR ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。<br>然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。<br>为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。<br>执行 BGREWRITEAOF 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。<br>Redis 2.2 需要自己手动执行 BGREWRITEAOF 命令； Redis 2.4 则可以自动触发 AOF 重写， 具体信息请查看 2.4 的示例配置文件。</p><h2 id="Rdis持久化设置："><a href="#Rdis持久化设置：" class="headerlink" title="Rdis持久化设置："></a>Rdis持久化设置：</h2><h4 id="查看下面配置文件："><a href="#查看下面配置文件：" class="headerlink" title="查看下面配置文件："></a>查看下面配置文件：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">默认Redis是开启的RDB模式的持久化</span></span><br><span class="line">vim /etc/redis/6379.conf</span><br><span class="line">=============================================================</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">############################### SNAPSHOTTING  ################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Save the DB on disk:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   Will save the DB <span class="keyword">if</span> both the given number of seconds and the given</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   number of write operations against the DB occurred.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   In the example below the behaviour will be to save:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   after 900 sec (15 min) <span class="keyword">if</span> at least 1 key changed</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   after 300 sec (5 min) <span class="keyword">if</span> at least 10 keys changed</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   after 60 sec <span class="keyword">if</span> at least 10000 keys changed</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   Note: you can <span class="built_in">disable</span> saving completely by commenting out all <span class="string">"save"</span> lines.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   It is also possible to remove all the previously configured save</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   points by adding a save directive with a single empty string argument</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   like <span class="keyword">in</span> the following example:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">   save <span class="string">""</span></span></span><br><span class="line"> </span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"> </span><br><span class="line">================================================================</span><br><span class="line"><span class="meta">#</span><span class="bash">上面3个save 是或的关系</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">   save &lt;seconds&gt; &lt;changes&gt;   <span class="comment">###格式！</span></span></span><br><span class="line">解释：</span><br><span class="line"><span class="meta">#</span><span class="bash">   after 900 sec (15 min) <span class="keyword">if</span> at least 1 key changed</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   after 300 sec (5 min) <span class="keyword">if</span> at least 10 keys changed</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   after 60 sec <span class="keyword">if</span> at least 10000 keys changed</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">900 sec内有1个key发生了改变就做一次快照 </span></span><br><span class="line"><span class="meta">#</span><span class="bash">或  300sec 内有10个keys发生了改变做一次快照   </span></span><br><span class="line"><span class="meta">#</span><span class="bash">或60 sec内 10000 keys发生了改变做一次快照</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">快照原理：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">forker出一个进程，是当前进程的一个副本相当于子进程，不会影响你当前运行的进程。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">当子进程写的时候会有一个临时的文件，当子进程写完之后会把这个</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">临时的文件move替换老的文件，所以这个rdb的文件任何时间都是一个完整的可用的副本！</span></span><br><span class="line"><span class="meta">#</span><span class="bash">你写的时候不会影响RDB这个文件，因为forker出的子进程正在写的是一个临时文件！</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">但是如果如果故障了，你这个保存的时间是你开始快照那一刻那个时间，你快照到快照完毕那一段时间的数据就丢失了！</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">如果想禁用持久化把这三行删了就行了</span></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><h4 id="快照保存在那里呢？"><a href="#快照保存在那里呢？" class="headerlink" title="快照保存在那里呢？"></a>快照保存在那里呢？</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> The filename <span class="built_in">where</span> to dump the DB</span></span><br><span class="line">dbfilename dump.rdb   #如果你启用了多个快照名称，可以使用端口好来定义比如：dump_6379.rdb</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that you must specify a directory here, not a file name.</span></span><br><span class="line">dir ./  #不仅仅是RDB模式下的DB存放在这个目录AOF模式下也是存放在这个目录的，建议存放在你指定的地方！</span><br><span class="line"> </span><br><span class="line">比如：</span><br><span class="line">dir /opt/redis/</span><br><span class="line"> </span><br><span class="line">比如我上面指定了：</span><br><span class="line"><span class="meta">#</span><span class="bash"> The filename <span class="built_in">where</span> to dump the DB</span></span><br><span class="line">dbfilename dump_6379.rdb</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that you must specify a directory here, not a file name.</span></span><br><span class="line">dir /opt/redis/</span><br></pre></td></tr></table></figure><h4 id="手动在Redis中保存"><a href="#手动在Redis中保存" class="headerlink" title="手动在Redis中保存"></a>手动在Redis中保存</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET key 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SAVE</span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line">下目录下面有没有修改：</span><br><span class="line">-rw-r--r-- 1 root root 27 Oct 14 13:35 dump_6379.rdb 当前时间创建</span><br><span class="line">在设置个key看下：</span><br><span class="line">127.0.0.1:6379&gt; SET key 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SAVE</span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line">-rw-r--r-- 1 root root 27 Oct 14 13:37 dump_6379.rdb</span><br><span class="line"> </span><br><span class="line">127.0.0.1:6379&gt; BGSAVE</span><br><span class="line">Background saving started</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">SAVE和BGSAVE有什么区别：SAVE 是阻塞的当你直接执行SAVE的时候他就不干活了，BGSAVE是在后台执行。forker一个子进程来进行SAVE！</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">SAVE的使用场景仅限于：当Redis需要迁移的时候，Redis没有数据写入并且可以停的时候使用！</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">测试添加一个：key然后停掉看看！不保存：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">目前的key是：</span></span><br><span class="line">127.0.0.1:6379&gt; KEYS *</span><br><span class="line">1) "key"</span><br><span class="line">2) "key2"</span><br><span class="line">3) "key3"</span><br><span class="line"> </span><br><span class="line">127.0.0.1:6379&gt; SET key4 4</span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">杀掉，重启之后发现设置的key丢失了。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">所以当redis异常挂掉之后，没有SAVE收据！</span></span><br></pre></td></tr></table></figure><h4 id="启用了AOF后"><a href="#启用了AOF后" class="headerlink" title="启用了AOF后"></a>启用了AOF后</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">给这个文件追加，把所有的命令都写到一个文件里面，你执行一个我写一个。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">恢复的话在执行一遍不就行了吗！非常简单 （但是恢复相对RDB模式回慢他相当于重新把AOF库里的记录重新往内存中写一边）</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">可以RDB和AOF同时使用！优点都占用了！但是也的根据业务来定！</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">开启方法：修改配置文件</span></span><br><span class="line">appendonly yes  #改为yes</span><br><span class="line">appendfilename "appendonly.aof"  #文件名</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">工作原理：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">forker 一个子进程写到临时文件，写完之后就给父进程发一个信号，开始写到写完的这个过程还会有子进程给父进程发信号。先保存在内存里</span></span><br><span class="line"><span class="meta">#</span><span class="bash">但是他有个好的功能，重写，他会定时对aof进行重新，这样文件就会非常小！</span></span><br><span class="line"> </span><br><span class="line">测试：（他会根据Redis可识别的方式写入文件，不过大概人也能看懂）</span><br><span class="line">[root@192.168.7.107]$ cat appendonly.aof</span><br><span class="line">*2</span><br><span class="line"><span class="meta">$</span><span class="bash">6</span></span><br><span class="line">SELECT</span><br><span class="line"><span class="meta">$</span><span class="bash">1</span></span><br><span class="line">0</span><br><span class="line">*3</span><br><span class="line"><span class="meta">$</span><span class="bash">3</span></span><br><span class="line">SET</span><br><span class="line"><span class="meta">$</span><span class="bash">4</span></span><br><span class="line">kye1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis持久化原理：&quot;&gt;&lt;a href=&quot;#Redis持久化原理：&quot; class=&quot;headerlink&quot; title=&quot;Redis持久化原理：&quot;&gt;&lt;/a&gt;Redis持久化原理：&lt;/h2&gt;&lt;p&gt;Redis支持两种持久化：&lt;strong&gt;RDB&lt;/strong&gt;和&lt;strong&gt;AOF&lt;/strong&gt;模式&lt;/p&gt;
    
    </summary>
    
      <category term="数据库运维" scheme="http://wandouduoduo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Redis" scheme="http://wandouduoduo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-cluster集群[一]:redis安装及redis数据类型</title>
    <link href="http://wandouduoduo.github.io/articles/88f598bf.html"/>
    <id>http://wandouduoduo.github.io/articles/88f598bf.html</id>
    <published>2019-07-30T06:25:29.000Z</published>
    <updated>2019-08-07T02:06:43.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis介绍："><a href="#Redis介绍：" class="headerlink" title="Redis介绍："></a>Redis介绍：</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h4><p>redis 是一个开源的、使用C语言编写的、支持网络交互的、可以基于内存也可以持久化的Key-Value数据库。</p><p>redis的源码非常简单，只要有时间看看谭浩强的C语言，在去看redis的源码能看懂50-60%。</p><p>redis目前最大的集群应该是新浪的应该。</p><p>redis目前是vmvaer来支持的，很多的开源软件都需要某些组织来支持的。如果一个开源软件没有金钱来支持的话很难走的持久</p><h4 id="Redis和Memcache对比"><a href="#Redis和Memcache对比" class="headerlink" title="Redis和Memcache对比"></a><strong>Redis和Memcache对比</strong></h4><p><img src="/articles/88f598bf/1.png" alt></p><p>持久化：以电商举例，session用memcache来做的，购物车用redis来做的，当你退出的时候会提示你购物车里的物品会在你退出后继续保存。相对来说memcache存储更单一化！</p><p>主从复制：redis的主从复制类似mysql的主从复制但是原理是不同的！</p><p>虚拟内存：说白了就是把内存里一些不用的东西放在硬盘上，最好不要用，降低效率，现在内存来说比较便宜。</p><a id="more"></a><h2 id="Redis安装-amp-基本操作："><a href="#Redis安装-amp-基本操作：" class="headerlink" title="Redis安装&amp;基本操作："></a>Redis安装&amp;基本操作：</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h4><h6 id="检查配置环境"><a href="#检查配置环境" class="headerlink" title="检查配置环境"></a>检查配置环境</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">检查gcc是否安装，如果没有安装：</span></span><br><span class="line">yum -y install gcc</span><br></pre></td></tr></table></figure><h6 id="下载安装Redis"><a href="#下载安装Redis" class="headerlink" title="下载安装Redis"></a>下载安装Redis</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/</span><br><span class="line">wget http://download.redis.io/releases/redis-3.0.4.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash">这里下载可以登录官网查看最新的Redis</span></span><br><span class="line">tar -xvf redis-3.0.4.tar.gz</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">cd /opt/redis-3.0.4/src/</span><br><span class="line">make test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装中可能遇到的问题：</span></span><br><span class="line">zmalloc.h:50:31: error: jemalloc/jemalloc.h: No such file or directory</span><br><span class="line">zmalloc.h:55:2: error: #error "Newer version of jemalloc required"</span><br><span class="line"> </span><br><span class="line">Allocator</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">Selecting a non-default memory allocator when building Redis is done by setting</span><br><span class="line">the `MALLOC` environment variable. Redis is compiled and linked against libc</span><br><span class="line">malloc by default, with the exception of jemalloc being the default on Linux</span><br><span class="line">systems. This default was picked because jemalloc has proven to have fewer</span><br><span class="line">fragmentation problems than libc malloc.</span><br><span class="line">To force compiling against libc malloc, use:</span><br><span class="line"><span class="meta">%</span><span class="bash"> make MALLOC=libc</span></span><br><span class="line">To compile against jemalloc on Mac OS X systems, use:</span><br><span class="line"><span class="meta">%</span><span class="bash"> make MALLOC=jemalloc</span></span><br><span class="line"> </span><br><span class="line">allocator（分配算符），如果有MALLOC这个环境变量，会有用这个环境变量的 去建立Redis。</span><br><span class="line">而且libc 并不是默认的分配器，默认的是jemalloc！</span><br><span class="line">因为jemalloc被证明有更少的fragmentation problems比libc。</span><br><span class="line"> </span><br><span class="line">但是如果你又没有jemalloc 而只有 libc 当然 make 出错。 所以加这么一个参数。</span><br><span class="line">make MALLOC=libc</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h6 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">复制管理脚本</span></span><br><span class="line">cp /opt/redis-3.0.4/utils/redis_init_script /etc/init.d/redis   </span><br><span class="line">chmod +x /etc/init.d/redis</span><br><span class="line">mkdir /etc/redis</span><br><span class="line">cp /opt/redis-3.0.4/redis.conf /etc/redis/6379.conf</span><br></pre></td></tr></table></figure><h6 id="修改redis启动模式"><a href="#修改redis启动模式" class="headerlink" title="修改redis启动模式"></a>修改redis启动模式</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">默认Redis启动的时候是启动在前台的，把他改为启动在后台</span></span><br><span class="line">vim /etc/redis/6379.conf</span><br><span class="line">daemonize no  改为 daemonize yes</span><br></pre></td></tr></table></figure><h6 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">首先修改Redis启动脚本：</span></span><br><span class="line">vim /etc/init.d/redis</span><br><span class="line"><span class="meta">#</span><span class="bash">chkconfig: 35 95 95  在第三行加上即可</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">添加系统服务：</span></span><br><span class="line">chkconfig --add redis</span><br><span class="line"><span class="meta">#</span><span class="bash">设置开机启动：</span></span><br><span class="line">chkconfig redis on</span><br><span class="line"><span class="meta">#</span><span class="bash">检查服务状态：</span></span><br><span class="line">chkconfig --list redis</span><br></pre></td></tr></table></figure><h6 id="指定日志存放位置-amp-PID文件-amp-数据库文件存放位置（下一边写持久化）"><a href="#指定日志存放位置-amp-PID文件-amp-数据库文件存放位置（下一边写持久化）" class="headerlink" title="指定日志存放位置&amp;PID文件&amp;数据库文件存放位置（下一边写持久化）"></a>指定日志存放位置&amp;PID文件&amp;数据库文件存放位置（下一边写持久化）</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/redis/6379.conf</span><br><span class="line"> </span><br><span class="line">logfile "/var/log/redis.log"  #指定日志文件如果不指定就会在控制台输出</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">dir ./   #这个是指默认的持久化配置文件放在那里！建议修改下！</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">pidfile如果不修改使用默认的话就会报错：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">原因是在/etc/init.d/redis里指定的默认PID是：PIDFILE=/var/run/redis_<span class="variable">$&#123;REDISPORT&#125;</span>.pid </span></span><br><span class="line"><span class="meta">#</span><span class="bash">但是默认配置文件：/etc/redis/6379.conf（咱们自己从解压包里复制的里的默认是：pidfile /var/run/redis.pid）</span></span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a><strong>基本操作</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SET 设置Key</span><br><span class="line">GET 判断Key的值</span><br><span class="line">EXISTS 判断Key是否存在</span><br><span class="line">KEYS * 显示所有的Key</span><br><span class="line">DEL 删除指定Key</span><br><span class="line">TYPE 获取Key类型</span><br></pre></td></tr></table></figure><p><strong>注：Redis是不区分大小写的，命令最好使用大写这样能区分是命令还是参数！</strong></p><h6 id="set的例子："><a href="#set的例子：" class="headerlink" title="set的例子："></a>set的例子：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.201:6379&gt; SET hello hehe</span><br><span class="line">OK</span><br><span class="line">192.168.0.201:6379&gt; GET hello</span><br><span class="line">"hehe"</span><br></pre></td></tr></table></figure><h6 id="设置多个key-value-然后使用使用keys-去查看所有"><a href="#设置多个key-value-然后使用使用keys-去查看所有" class="headerlink" title="设置多个key value 然后使用使用keys * 去查看所有"></a>设置多个key value 然后使用使用keys * 去查看所有</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.201:6379&gt; SET hello1 hehe1</span><br><span class="line">OK</span><br><span class="line">192.168.0.201:6379&gt; SET hello2 hehe2</span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line">192.168.0.201:6379&gt; KEYS  *</span><br><span class="line">1) "hello1"</span><br><span class="line">2) "hello"</span><br><span class="line">3) "hello2"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">KEY匹配方式：</span></span><br><span class="line">？匹配单个</span><br><span class="line"> *匹配所有</span><br></pre></td></tr></table></figure><h6 id="判断key是否存在"><a href="#判断key是否存在" class="headerlink" title="判断key是否存在"></a>判断key是否存在</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">判断Key是否存在使用：EXISTS   他返回的是整形：0不存在，1存在</span></span><br><span class="line">192.168.0.201:6379&gt; EXISTS hello</span><br><span class="line">(integer) 1</span><br><span class="line">192.168.0.201:6379&gt; EXISTS hehe</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><h6 id="删除KEY"><a href="#删除KEY" class="headerlink" title="删除KEY"></a>删除KEY</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.201:6379&gt; DEL hello</span><br><span class="line">(integer) 1   #这里的1是数量</span><br><span class="line"><span class="meta">#</span><span class="bash">删除多个测试下：</span></span><br><span class="line">192.168.0.201:6379&gt; DEL hello1 hello2</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h6 id="查看类型TYPE"><a href="#查看类型TYPE" class="headerlink" title="查看类型TYPE"></a>查看类型TYPE</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">只要用<span class="built_in">set</span>类型就是字符串。查看类型命令用TYPE</span></span><br><span class="line">192.168.0.201:6379&gt; TYPE hello</span><br><span class="line">string</span><br></pre></td></tr></table></figure><h6 id="Keyspace"><a href="#Keyspace" class="headerlink" title="Keyspace"></a>Keyspace</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">redis是支持多个实例的默认最多16个，可以修改配置文件来支持更多！</span></span><br><span class="line"><span class="meta">#</span><span class="bash">使用INFO命令查看！</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keyspace</span></span><br><span class="line">db0:keys=1,expires=0,avg_ttl=0</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">db0 ：这个可以理解为命名空间。最多支持16个，使用SELECT 去切换</span></span><br><span class="line">192.168.0.201:6379&gt; SELECT 1</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash">尝试添加一个key-value</span></span><br><span class="line">SET db1 hehe</span><br><span class="line"><span class="meta">#</span><span class="bash">然后在使用INFO看下</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keyspace</span></span><br><span class="line">db0:keys=1,expires=0,avg_ttl=0</span><br><span class="line">db1:keys=1,expires=0,avg_ttl=0</span><br></pre></td></tr></table></figure><h2 id="Redis数据类型："><a href="#Redis数据类型：" class="headerlink" title="Redis数据类型："></a>Redis数据类型：</h2><p>他用不同的命令来区分你要操作什么数据类型<br>类型不能嵌套，不能混！ 但是有个王炸：set能把所有的类型都改为字符串类型！</p><h4 id="字符串类型："><a href="#字符串类型：" class="headerlink" title="字符串类型："></a>字符串类型：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SET</span><br><span class="line">GET</span><br><span class="line">DEL</span><br><span class="line">APPEND  在值的后面追加</span><br><span class="line">set能重新设置但是要追加的话使用APPEND最好比如</span><br><span class="line">192.168.0.201:6379&gt; SET hehe hello</span><br><span class="line">OK</span><br><span class="line">192.168.0.201:6379&gt; GET hehe</span><br><span class="line">"hello"</span><br><span class="line">192.168.0.201:6379&gt; APPEND hehe ,world</span><br><span class="line">(integer) 11</span><br><span class="line">192.168.0.201:6379&gt; GET hehe</span><br><span class="line">"hello,world"</span><br><span class="line"> </span><br><span class="line">可以同时设置多个值和查询值用MSET 和MSET</span><br><span class="line">192.168.0.201:6379&gt; MSET key1 v1 key2 v2 key3 v3</span><br><span class="line">OK</span><br><span class="line">192.168.0.201:6379&gt; MGET key1 key2 key3</span><br><span class="line">1) "v1"</span><br><span class="line">2) "v2"</span><br><span class="line">3) "v3"</span><br><span class="line"> </span><br><span class="line">获取字符串长度</span><br><span class="line">192.168.0.201:6379&gt; STRLEN hehe</span><br><span class="line">(integer) 11</span><br><span class="line">如果字符串是中文的他会按照UTF-8格式的来输出1个字等3个字符串来算的  )</span><br><span class="line">192.168.0.201:6379&gt; SET key "呵呵"</span><br><span class="line">OK</span><br><span class="line">192.168.0.201:6379&gt; GET key</span><br><span class="line">"\xe5\x91\xb5\xe5\x91\xb5"</span><br></pre></td></tr></table></figure><h4 id="自增类型"><a href="#自增类型" class="headerlink" title="自增类型"></a>自增类型</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">比如说投票点下+1 ，如果说用<span class="built_in">set</span>每点一次修改<span class="built_in">set</span>下那就不太现实。所有redis有个自增类型：INCR</span></span><br><span class="line">192.168.0.201:6379&gt; INCR num           #默认如果没有这个值的话，INCR就会自动创建一个值默认为零，当你没执行一次他就会+1</span><br><span class="line">(integer) 1</span><br><span class="line">192.168.0.201:6379&gt; INCR num</span><br><span class="line">(integer) 2</span><br><span class="line">192.168.0.201:6379&gt; INCR num</span><br><span class="line">(integer) 3</span><br><span class="line">192.168.0.201:6379&gt; INCR num</span><br><span class="line">(integer) 4</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">如果想加多个呢：INCRBY</span></span><br><span class="line">192.168.0.201:6379&gt; INCRBY num 10</span><br><span class="line">(integer) 57</span><br><span class="line">192.168.0.201:6379&gt; INCRBY num 10</span><br><span class="line">(integer) 67</span><br><span class="line">192.168.0.201:6379&gt; INCRBY num 10</span><br><span class="line">(integer) 77</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">减呢？ DECR</span></span><br><span class="line">192.168.0.201:6379&gt; DECR num</span><br><span class="line">(integer) 106</span><br><span class="line">192.168.0.201:6379&gt; DECR num</span><br><span class="line">(integer) 105</span><br><span class="line">192.168.0.201:6379&gt; DECR num</span><br><span class="line">(integer) 104</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">如果要是减多个呢：DECRBY</span></span><br><span class="line">192.168.0.201:6379&gt; DECRBY num 5</span><br><span class="line">(integer) 97</span><br><span class="line">192.168.0.201:6379&gt; DECRBY num 5</span><br><span class="line">(integer) 92</span><br><span class="line">192.168.0.201:6379&gt; DECRBY num 5</span><br><span class="line">(integer) 87</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">想支持小数点：</span></span><br><span class="line">INCRBYFLOAT key 0.1</span><br><span class="line">192.168.0.201:6379&gt; INCRBYFLOAT key 0.1</span><br><span class="line">"0.1"</span><br><span class="line">192.168.0.201:6379&gt; INCRBYFLOAT key 0.1</span><br><span class="line">"0.2"</span><br><span class="line">192.168.0.201:6379&gt; INCRBYFLOAT key 0.1</span><br><span class="line">"0.3"</span><br><span class="line">192.168.0.201:6379&gt; INCRBYFLOAT key 0.1</span><br><span class="line">"0.4"</span><br></pre></td></tr></table></figure><h4 id="散列类型（hash）"><a href="#散列类型（hash）" class="headerlink" title="散列类型（hash）"></a>散列类型（hash）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">和数据库存的表似的，表不是的有字段吧，可以给每个字段设置个值</span></span><br><span class="line">HSET Key field value</span><br><span class="line">HGET Key field</span><br><span class="line">HMSET Key field value [field value....]</span><br><span class="line">HMGET Key field [field ...]</span><br><span class="line">HGETALL Key</span><br><span class="line">HDEL</span><br><span class="line"> </span><br><span class="line">192.168.0.201:6379&gt; HSET shouji name iphone</span><br><span class="line">(integer) 1</span><br><span class="line">192.168.0.201:6379&gt; HSET shouji co red</span><br><span class="line">(integer) 1</span><br><span class="line">192.168.0.201:6379&gt; HSET shouji price 8888</span><br><span class="line">(integer) 1</span><br><span class="line"> </span><br><span class="line">192.168.0.201:6379&gt; HGET shouji name</span><br><span class="line">"iphone"</span><br><span class="line">192.168.0.201:6379&gt; HGET shouji co</span><br><span class="line">"red"</span><br><span class="line">192.168.0.201:6379&gt; HGET shouji price</span><br><span class="line">"8888"</span><br><span class="line">192.168.0.201:6379&gt; HGETALL shouji</span><br><span class="line">1) "name"</span><br><span class="line">2) "iphone"</span><br><span class="line">3) "co"</span><br><span class="line">4) "red"</span><br><span class="line">5) "price"</span><br><span class="line">6) "8888"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">其实现在看着不是好看的但是他通过一些API调用到网页上，通过排版取出来的值就好看了</span></span><br><span class="line">192.168.0.201:6379&gt; HMSET diannao name thinkpad co black price 30</span><br><span class="line">OK</span><br><span class="line">192.168.0.201:6379&gt; HMGET diannao name co price</span><br><span class="line">1) "thinkpad"</span><br><span class="line">2) "black"</span><br><span class="line">3) "30"</span><br></pre></td></tr></table></figure><h4 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">列表类型：他是存储一个有序的字符串列表   这个“有序”是什么时候进来的！</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">列表你向左边添加和右边添加他的时间复杂度是一样的！O1（时间复杂度）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">可以理解为：我这个速度不随着数量的增加而增加！比如1000行和1万行他的时间开销是一样的！    大学数据结构里学的</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">时间复杂度：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">但是他有个缺点，比如说里面有1万个key你想找到第98个这就费老劲了他从1开始数数到98</span></span><br><span class="line"><span class="meta">#</span><span class="bash">优点，你读前100个，卡直接读头部就非常快了</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">命令：</span></span><br><span class="line">LPUSH key value [value ...]</span><br><span class="line">RPUSH key value [value ...]</span><br><span class="line">               LPOP key</span><br><span class="line">               RPOP key</span><br><span class="line">     LRANGE key start stop</span><br><span class="line">     LREM key count value</span><br><span class="line"><span class="meta">#</span><span class="bash">从左边添加key</span></span><br><span class="line">192.168.0.201:6379&gt; LPUSH num 0</span><br><span class="line">(integer) 1</span><br><span class="line">192.168.0.201:6379&gt; LPUSH num 1</span><br><span class="line">(integer) 2</span><br><span class="line">192.168.0.201:6379&gt; LPUSH num 2</span><br><span class="line">(integer) 3</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">现在是从左边加</span></span><br><span class="line">2  1   0</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">从右边开始加</span></span><br><span class="line">192.168.0.201:6379&gt; RPUSH num 3</span><br><span class="line">(integer) 4</span><br><span class="line">2  1   0  3</span><br><span class="line"> </span><br><span class="line">192.168.0.201:6379&gt; RPUSH num 5</span><br><span class="line">(integer) 5</span><br><span class="line"> </span><br><span class="line">2  1  0  3  5  5</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">如果想获取长度就使用LNE 吗！获取列表类型长度就是：LLEN</span></span><br><span class="line">192.168.0.201:6379&gt; LLEN num</span><br><span class="line">(integer) 5</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">从左边拿key</span></span><br><span class="line"><span class="meta">#</span><span class="bash">从列表类型里拿出这个key来（拿出来就没有了），从左边拿左边第一个</span></span><br><span class="line">192.168.0.201:6379&gt; LPOP num</span><br><span class="line">"2"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">左边第一个是2那么拿出来之后这个key这个key就变成</span></span><br><span class="line">1  0  3  5</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">从右边拿key，从右边拿右边第一个   （这个5就被拿出来了）</span></span><br><span class="line">192.168.0.201:6379&gt; RPOP num</span><br><span class="line">"5"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">现在在看下这个key的长度</span></span><br><span class="line">192.168.0.201:6379&gt; LLEN num</span><br><span class="line">(integer) 3</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">获取列表的某一个范围：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">现在是这个值</span></span><br><span class="line">1  0  3</span><br><span class="line"> </span><br><span class="line">192.168.0.201:6379&gt; LRANGE num 0 1              #取0 - 1 的值</span><br><span class="line">1) "1"</span><br><span class="line">2) "0"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##这个列表和python中列表中差不多，0 -1 相当于列表中的下标。</span></span></span><br><span class="line"> </span><br><span class="line">192.168.0.201:6379&gt; LPUSH num 2</span><br><span class="line">(integer) 4</span><br><span class="line">192.168.0.201:6379&gt; RPUSH num 4</span><br><span class="line">(integer) 5</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">192.168.0.201:6379&gt; LRANGE num 0 -1     #这里的（-1）表示左边第一个</span><br><span class="line">1) "2"</span><br><span class="line">2) "1"</span><br><span class="line">3) "0"</span><br><span class="line">4) "3"</span><br><span class="line">5) "4"</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">获取指定元素的值</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">获取右边的第一个值：</span></span><br><span class="line">192.168.0.201:6379&gt; LINDEX num -1</span><br><span class="line">"4"</span><br><span class="line"><span class="meta">#</span><span class="bash">获取左边边的第二个值：</span></span><br><span class="line">192.168.0.201:6379&gt; LINDEX num -2</span><br><span class="line">"3"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">那-3呢？</span></span><br><span class="line">192.168.0.201:6379&gt; LINDEX num -3</span><br><span class="line">"0"</span><br><span class="line"><span class="meta">#</span><span class="bash">这个就是从右边数的第3个值！！！！！</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">从左边获取值</span></span><br><span class="line">192.168.0.201:6379&gt; LINDEX num 0</span><br><span class="line">"2"</span><br><span class="line">192.168.0.201:6379&gt; LINDEX num 1</span><br><span class="line">"1"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">他是两边的第一次接触有点乱！他是两边的需要注意！！！</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">只保留指定数据</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">只保留0到2的数据</span></span><br><span class="line">192.168.0.201:6379&gt; LTRIM num 0 2</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash">看下结果：</span></span><br><span class="line">192.168.0.201:6379&gt; LRANGE num 0 -1</span><br><span class="line">1) "2"</span><br><span class="line">2) "1"</span><br><span class="line">3) "0"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">这个有什么用呢：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">写日志的时候，我这个缓冲区，只保留最近100条日志！</span></span><br><span class="line"><span class="meta">#</span><span class="bash">比如：</span></span><br><span class="line">192.168.0.201:6379&gt; LPUSH logs newloghehe</span><br><span class="line">(integer) 1</span><br><span class="line"> </span><br><span class="line">192.168.0.201:6379&gt; LTRIM num 0 99</span><br><span class="line">OK</span><br><span class="line"> </span><br><span class="line">这样的话我的列表永远只有100条，我只看最近100条的日志！！</span><br></pre></td></tr></table></figure><h4 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">集合是高一学的，第一个学期就是学的集合</span></span><br><span class="line"><span class="meta">#</span><span class="bash">交集∩、并集∪、合集、等 0 0 ！</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">集合的元素是没有类型的！</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用到集合类型的应用有：（新浪微博分享了很多的redis应用）</span></span><br><span class="line"><span class="meta">#</span><span class="bash">比如：关注微博，比如咱俩是否共同关注了某一个人等。</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">添加集合</span></span><br><span class="line">192.168.0.201:6379&gt; SADD jihe1 a b c</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看集合内容</span></span><br><span class="line">192.168.0.201:6379&gt; SMEMBERS jihe1</span><br><span class="line">1) "c"</span><br><span class="line">2) "a"</span><br><span class="line">3) "b"</span><br><span class="line"><span class="meta">#</span><span class="bash">判断集合元素是否存在</span></span><br><span class="line">192.168.0.201:6379&gt; SISMEMBER jihe1 d</span><br><span class="line">(integer) 0</span><br><span class="line">192.168.0.201:6379&gt; SISMEMBER jihe1 a</span><br><span class="line">(integer) 1</span><br><span class="line">返回0 说明不存在返回1说明存存在</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">集合间运算</span></span><br><span class="line"><span class="meta">#</span><span class="bash">支持：交集、差集、并集</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">差集运算：</span></span><br><span class="line">192.168.0.201:6379&gt; SDIFF jihe1 jihe2</span><br><span class="line">1) "a"</span><br><span class="line">jihe1abcjihe2b cd</span><br><span class="line"> </span><br><span class="line">jihe1 减去jihe2 减去相同的b c  ,  jihe1 还剩下a</span><br><span class="line"> </span><br><span class="line">同理：</span><br><span class="line">jihe2 减去jihe1</span><br><span class="line">192.168.0.201:6379&gt; SDIFF jihe2 jihe1</span><br><span class="line">1) "d"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">差集运算可以设置多个</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">交集运算：</span></span><br><span class="line"> 192.168.0.201:6379&gt; SINTER jihe1 jihe2</span><br><span class="line">1) "c"</span><br><span class="line">2) "b"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">交集可以设置多个：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">在添加一个jihe3</span></span><br><span class="line">192.168.0.201:6379&gt; SADD jihe3 d e f</span><br><span class="line">(integer) 3</span><br><span class="line"> </span><br><span class="line">192.168.0.201:6379&gt; SINTER jihe1 jihe2 jihe3</span><br><span class="line">(empty list or set)</span><br><span class="line"><span class="meta">#</span><span class="bash">这个是因为他是jihe1和jihe2先做交集运算，然后在和jihe3做交集运算</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">并集运算</span></span><br><span class="line">192.168.0.201:6379&gt; SUNION jihe1 jihe2</span><br><span class="line">1) "a"</span><br><span class="line">2) "c"</span><br><span class="line">3) "b"</span><br><span class="line">4) "d"</span><br><span class="line"><span class="meta">#</span><span class="bash">同样也可以设置多个</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">以上的集合是无序的，redis支持有序的集合他的名如下</span></span><br><span class="line">ZADD key score member 增加元素</span><br><span class="line">ZSCORE key member 获取元素的分数</span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line">ZRANGEBYSCORE key min max</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">添加有序集合</span></span><br><span class="line">192.168.0.201:6379&gt; ZSCORE youxu 80 a</span><br><span class="line">(nil)</span><br><span class="line">192.168.0.201:6379&gt; ZADD youxu 81 b</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash">可以添加多个</span></span><br><span class="line">192.168.0.201:6379&gt; ZADD youxu 82 c 83 d</span><br><span class="line">(integer) 2</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">获取分数</span></span><br><span class="line">192.168.0.201:6379&gt; ZSCORE youxu a</span><br><span class="line">"80"</span><br><span class="line">192.168.0.201:6379&gt; ZSCORE youxu b</span><br><span class="line">"81"</span><br><span class="line">192.168.0.201:6379&gt; ZSCORE youxu c</span><br><span class="line">"82"</span><br><span class="line">192.168.0.201:6379&gt; ZSCORE youxu d</span><br><span class="line">"83"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">获取有序集合范围</span></span><br><span class="line">192.168.0.201:6379&gt; ZRANGE youxu 0 3   #参考列表集合的0 3  从0到3的元素</span><br><span class="line">1) "a"</span><br><span class="line">2) "b"</span><br><span class="line">3) "c"</span><br><span class="line">4) "d"</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">在举个例子：</span></span><br><span class="line">192.168.0.201:6379&gt; ZADD youxu 79 e</span><br><span class="line">(integer) 1</span><br><span class="line"> </span><br><span class="line">192.168.0.201:6379&gt; ZRANGE youxu 0 4</span><br><span class="line">1) "e"</span><br><span class="line">2) "a"</span><br><span class="line">3) "b"</span><br><span class="line">4) "c"</span><br><span class="line">5) "d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis介绍：&quot;&gt;&lt;a href=&quot;#Redis介绍：&quot; class=&quot;headerlink&quot; title=&quot;Redis介绍：&quot;&gt;&lt;/a&gt;Redis介绍：&lt;/h2&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;redis 是一个开源的、使用C语言编写的、支持网络交互的、可以基于内存也可以持久化的Key-Value数据库。&lt;/p&gt;
&lt;p&gt;redis的源码非常简单，只要有时间看看谭浩强的C语言，在去看redis的源码能看懂50-60%。&lt;/p&gt;
&lt;p&gt;redis目前最大的集群应该是新浪的应该。&lt;/p&gt;
&lt;p&gt;redis目前是vmvaer来支持的，很多的开源软件都需要某些组织来支持的。如果一个开源软件没有金钱来支持的话很难走的持久&lt;/p&gt;
&lt;h4 id=&quot;Redis和Memcache对比&quot;&gt;&lt;a href=&quot;#Redis和Memcache对比&quot; class=&quot;headerlink&quot; title=&quot;Redis和Memcache对比&quot;&gt;&lt;/a&gt;&lt;strong&gt;Redis和Memcache对比&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/articles/88f598bf/1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;持久化：以电商举例，session用memcache来做的，购物车用redis来做的，当你退出的时候会提示你购物车里的物品会在你退出后继续保存。相对来说memcache存储更单一化！&lt;/p&gt;
&lt;p&gt;主从复制：redis的主从复制类似mysql的主从复制但是原理是不同的！&lt;/p&gt;
&lt;p&gt;虚拟内存：说白了就是把内存里一些不用的东西放在硬盘上，最好不要用，降低效率，现在内存来说比较便宜。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库运维" scheme="http://wandouduoduo.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Redis" scheme="http://wandouduoduo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Python之进程线程协程</title>
    <link href="http://wandouduoduo.github.io/articles/fa6bf072.html"/>
    <id>http://wandouduoduo.github.io/articles/fa6bf072.html</id>
    <published>2019-07-29T01:37:25.000Z</published>
    <updated>2019-08-07T02:06:43.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Socket-Server模块"><a href="#Socket-Server模块" class="headerlink" title="Socket Server模块"></a>Socket Server模块</h2><p>SocketServer内部使用 IO多路复用 以及 “多线程” 和 “多进程” ，从而实现并发处理多个客户端请求的Socket服务端。即：每个客户端请求连接到服务器时，Socket服务端都会在服务器是创建一个“线程”或者“进程” 专门负责处理当前客户端的所有请求。</p><p>socket server和select &amp; epoll 还是不太一样他的本质是：客户端第一次链接的时候，只要一进来，我服务端有个while循环为你创建一个<br>线程和进程，客户端就和服务端直接创建通信，以后传送数据什么的就不会通过server端了，直接他俩通过线程或者进程通信就可以了！</p><p>如果在多进程的时候，client1和client2他们同时传输10G的文件都是互相不影响！<br>如果在多线程的时候，python中的多线程，在同一时间只有一个线程在工作，他底层会自动进行上下文切换，client1传一点，client2传一点。</p><p>知识回顾：<br>python中的多线程，有一个GIL在同一时间只有一个线程在工作，他底层会自动进行上下文切换.<br>这样会导致python的多线程效率会很低，也就是人们经常说的python多线程问题</p><p>如下图：</p><p>第一次连接后，数据通讯就通过线程或进程进行数据交换（红色箭头）</p><p><img src="/articles/fa6bf072/1.png" alt></p><h2 id="ThreadingTCPServer"><a href="#ThreadingTCPServer" class="headerlink" title="ThreadingTCPServer"></a><strong>ThreadingTCPServer</strong></h2><p>ThreadingTCPServer实现的Socket服务器内部会为每个client创建一个 “<strong>线程</strong>”，该线程用来和客户端进行交互。</p><h4 id="ThreadingTCPServer基础"><a href="#ThreadingTCPServer基础" class="headerlink" title="ThreadingTCPServer基础"></a>ThreadingTCPServer基础</h4><p>使用ThreadingTCPServer:</p><ul><li>创建一个继承自 SocketServer.BaseRequestHandler 的类</li><li>类中必须定义一个名称为 handle 的方法</li><li>启动ThreadingTCPServer</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> SocketServer</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyServer</span><span class="params">(SocketServer.BaseRequestHandler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span> <span class="comment">#定义handle方法</span></span><br><span class="line">        <span class="comment"># print self.request,self.client_address,self.server</span></span><br><span class="line">        conn = self.request <span class="comment">#如果连接请求过来，获取client端对象</span></span><br><span class="line">        conn.sendall(<span class="string">'欢迎致电 10086，请输入1xxx,0转人工服务.'</span>) <span class="comment">#发送一个信息</span></span><br><span class="line">        Flag = <span class="literal">True</span> <span class="comment">#并把Flag设置为True</span></span><br><span class="line">        <span class="keyword">while</span> Flag:当Flag为<span class="literal">True</span>的时候执行</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>) <span class="comment">#接收client端数据</span></span><br><span class="line">            <span class="keyword">if</span> data == <span class="string">'exit'</span>: <span class="comment">#判断如果data  == 'exit' 退出</span></span><br><span class="line">                Flag = <span class="literal">False</span> <span class="comment">#并把Flag设置为Flase</span></span><br><span class="line">            <span class="keyword">elif</span> data == <span class="string">'0'</span>: <span class="comment">#如果为 == ‘0’ </span></span><br><span class="line">                conn.sendall(<span class="string">'通过可能会被录音.balabala一大推'</span>) <span class="comment">#发送数据</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment">#上面的都没匹配上，发送请重新输入</span></span><br><span class="line">                conn.sendall(<span class="string">'请重新输入.'</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    server = SocketServer.ThreadingTCPServer((<span class="string">'127.0.0.1'</span>,<span class="number">8009</span>),MyServer) <span class="comment">#实例化对象，设置启动的IP/PORT并把自己定义的类写上作为SocketServer.ThreadingTCPServer的构造函数</span></span><br><span class="line">    server.serve_forever() <span class="comment">#调用对象中的启动方法</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>,<span class="number">8009</span>)</span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect(ip_port)</span><br><span class="line">sk.settimeout(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = sk.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'receive:'</span>,data</span><br><span class="line">    inp = raw_input(<span class="string">'please input:'</span>)</span><br><span class="line">    sk.sendall(inp)</span><br><span class="line">    <span class="keyword">if</span> inp == <span class="string">'exit'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure><h4 id="ThreadingTCPServer源码剖析"><a href="#ThreadingTCPServer源码剖析" class="headerlink" title="ThreadingTCPServer源码剖析"></a>ThreadingTCPServer源码剖析</h4><p> <img src="/articles/fa6bf072/2.png" alt></p><p>学会看源码非常重要！不能仅仅光会用！大赞~ 知道他的过程和实现~ 怎么学会看源码呢？多看然后画类图，如上图！！！</p><p>在理解的时候可以把他们想象为，把所有需要用的方法，都抓到ThreadingTCPServer中</p><p>内部调用流程为：</p><ul><li>启动服务端程序</li><li>执行 TCPServer.<strong>init</strong> 方法，创建服务端Socket对象并绑定 IP 和 端口</li><li>执行 BaseServer.<strong>init</strong> 方法，将自定义的继承自SocketServer.BaseRequestHandler 的类 MyRequestHandle赋值给 self.RequestHandlerClass</li><li>执行 BaseServer.server_forever 方法，While 循环一直监听是否有客户端请求到达 …</li><li>当客户端连接到达服务器</li><li>执行 ThreadingMixIn.process_request 方法，创建一个 “线程” 用来处理请求</li><li>执行 ThreadingMixIn.process_request_thread 方法</li><li>执行 BaseServer.finish_request 方法，执行 self.RequestHandlerClass()  即：执行 自定义 MyRequestHandler 的构造方法（自动调用基类BaseRequestHandler的构造方法，在该构造方法中又会调用 MyRequestHandler的handle方法）</li></ul><p>精简源码：</p><p>模拟Socekt Server的简化版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(request, client_address)</span>:</span> <span class="comment">#模拟定义的handle()方法，这个方法内的代码是socket server与Client端交互代码</span></span><br><span class="line">    <span class="keyword">print</span> request,client_address</span><br><span class="line">    conn = request</span><br><span class="line">    conn.sendall(<span class="string">'欢迎致电 10086，请输入1xxx,0转人工服务.'</span>)</span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> flag:</span><br><span class="line">        data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">'exit'</span>:</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> data == <span class="string">'0'</span>:</span><br><span class="line">            conn.sendall(<span class="string">'通过可能会被录音.balabala一大推'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            conn.sendall(<span class="string">'请重新输入.'</span>)</span><br><span class="line"></span><br><span class="line">sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8002</span>))</span><br><span class="line">sk.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment">#这里一个while循环循环监控sk文件句柄</span></span><br><span class="line">    r, w, e = select.select([sk,],[],[],<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'looping'</span></span><br><span class="line">    <span class="keyword">if</span> sk <span class="keyword">in</span> r: <span class="comment">#当sk文件句柄发生变化的时候说明是新的客户端连接过来了</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'get request'</span></span><br><span class="line">        request, client_address = sk.accept()</span><br><span class="line">        t = threading.Thread(target=process, args=(request, client_address)) <span class="comment">#创建一个线程，并调用自己定义的process方法执行~然后样客户端与之交互</span></span><br><span class="line">        t.daemon = <span class="literal">False</span></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure><p>如精简代码可以看出，SocketServer的ThreadingTCPServer之所以可以同时处理请求得益于 <strong>select</strong> 和 <strong>Threading</strong> 两个东西，其实本质上就是在服务器端为每一个客户端创建一个线程，当前线程用来处理对应客户端的请求，所以，可以支持同时n个客户端链接（长连接）。</p><p><strong>ForkingTCPServer</strong></p><p>ForkingTCPServer和ThreadingTCPServer的使用和执行流程基本一致，只不过在内部分别为请求者建立 “线程”  和 “进程”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> SocketServer</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyServer</span><span class="params">(SocketServer.BaseRequestHandler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># print self.request,self.client_address,self.server</span></span><br><span class="line">        conn = self.request</span><br><span class="line">        conn.sendall(<span class="string">'欢迎致电 10086，请输入1xxx,0转人工服务.'</span>)</span><br><span class="line">        Flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> Flag:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> data == <span class="string">'exit'</span>:</span><br><span class="line">                Flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> data == <span class="string">'0'</span>:</span><br><span class="line">                conn.sendall(<span class="string">'通过可能会被录音.balabala一大推'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                conn.sendall(<span class="string">'请重新输入.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    server = SocketServer.ForkingTCPServer((<span class="string">'127.0.0.1'</span>,<span class="number">8009</span>),MyServer)</span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>,<span class="number">8009</span>)</span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect(ip_port)</span><br><span class="line">sk.settimeout(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = sk.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'receive:'</span>,data</span><br><span class="line">    inp = raw_input(<span class="string">'please input:'</span>)</span><br><span class="line">    sk.sendall(inp)</span><br><span class="line">    <span class="keyword">if</span> inp == <span class="string">'exit'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure><p>以上ForkingTCPServer只是将 ThreadingTCPServer 实例中的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server = SocketServer.ThreadingTCPServer((<span class="string">'127.0.0.1'</span>,<span class="number">8009</span>),MyRequestHandler)</span><br><span class="line">变更为：</span><br><span class="line">server = SocketServer.ForkingTCPServer((<span class="string">'127.0.0.1'</span>,<span class="number">8009</span>),MyRequestHandler)</span><br></pre></td></tr></table></figure><h2 id="Python线程"><a href="#Python线程" class="headerlink" title="Python线程"></a>Python线程</h2><p>Threading用于提供线程相关的操作，线程是应用程序中工作的最小单元。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'thread'</span>+str(arg)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=show, args=(i,))  <span class="comment">#这里实例化对象的时候传的两个参数第一个参数是，线程需要执行的方法，第二个参数方法的参数</span></span><br><span class="line">    t.start()</span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> <span class="string">'main thread stop'</span></span><br></pre></td></tr></table></figure><p>上述代码创建了10个“前台”线程，然后控制器就交给了CPU，CPU根据指定算法进行调度，分片执行指令。</p><p>再次回顾：这里为什么是分片执行？</p><p>python中的多线程，有一个GIL（Global Interpreter Lock 全局解释器锁 ）在同一时间只有一个线程在工作，他底层会自动进行上下文切换.这个线程执行点，那个线程执行点！</p><p><strong>更多方法：</strong></p><ul><li>start       线程准备就绪，等待CPU调度</li><li>setName     为线程设置名称</li><li>getName     获取线程名称</li><li>setDaemon   设置为后台线程或前台线程（默认）</li><li>​            如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，均停止</li><li>​            如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，程序停止</li><li>join        逐个执行每个线程，执行完毕后继续往下执行，该方法使得多线程变得无意义</li><li>run         线程被cpu调度后执行Thread类对象的run方法</li></ul><p><strong>线程锁</strong></p><p>由于线程之间是进行随机调度，并且每个线程可能只执行n条执行之后，CPU接着执行其他线程。所以，可能出现如下问题：</p><p><img src="/articles/fa6bf072/3.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">gl_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> gl_num</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    gl_num +=<span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> gl_num</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=show, args=(i,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'main thread stop'</span></span><br></pre></td></tr></table></figure><p><strong>设置线程锁</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">   </span><br><span class="line">gl_num = <span class="number">0</span></span><br><span class="line">   </span><br><span class="line">lock = threading.RLock() <span class="comment">#实例化调用线程锁</span></span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Func</span><span class="params">()</span>:</span></span><br><span class="line">    lock.acquire() <span class="comment">#获取线程锁</span></span><br><span class="line">    <span class="keyword">global</span> gl_num</span><br><span class="line">    gl_num +=<span class="number">1</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> gl_num</span><br><span class="line">    lock.release() <span class="comment">#释放线程锁，这里注意，在使用线程锁的时候不能把锁，写在代码中，否则会造成阻塞，看起来“像”单线程</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=Func)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p><strong>event</strong></p><p>他的作用就是：用主线程控制子线程合适执行，他可以让子线程停下来，也可以让线程继续！<br>他实现的机制就是：标志位“Flag”</p><p>事件处理的机制：全局定义了一个“Flag”，如果“Flag”值为 False，那么当程序执行 event.wait 方法时就会阻塞，如果“Flag”值为True，那么event.wait 方法时便不再阻塞。</p><ul><li>clear：将“Flag”设置为False</li><li>set：将“Flag”设置为True</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do</span><span class="params">(event)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'start'</span></span><br><span class="line">    event.wait() <span class="comment">#执行对象weit方法，然后他们停下来，等待“Flag”为True</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'execute'</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">event_obj = threading.Event() <span class="comment">#创建事件的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=do, args=(event_obj,)) <span class="comment">#吧对象传到每个线程里面了~</span></span><br><span class="line">    t.start()</span><br><span class="line"> </span><br><span class="line">event_obj.clear()  <span class="comment">#设置"Flag"为Flase</span></span><br><span class="line"></span><br><span class="line">inp = raw_input(<span class="string">'input:'</span>)</span><br><span class="line"><span class="keyword">if</span> inp == <span class="string">'true'</span>:</span><br><span class="line">    event_obj.set()</span><br><span class="line">    </span><br><span class="line"><span class="comment">#thread enent 就是这个3个方法的使用</span></span><br></pre></td></tr></table></figure><h2 id="Python进程"><a href="#Python进程" class="headerlink" title="Python进程"></a>Python进程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'say hi'</span>,i</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    p = Process(target=foo,args=(i,))</span><br><span class="line">    p.start()</span><br></pre></td></tr></table></figure><p><strong>注意：由于进程之间的数据需要各自持有一份，所以创建进程需要的非常大的开销。并且python不能再Windows下创建进程！</strong></p><p>并且在使用多进程的时候，最好是创建多少个进程？：和CPU核数相等</p><p>默认的进程之间相互是独立，如果想让进程之间数据共享，就得有个特殊的数据结构，这个数据结构就可以理解为他有穿墙的功能<br>如果你能穿墙的话两边就都可以使用了<br>使用了3种方法</p><p><strong>默认的进程无法进行数据共享：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line">li = []</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(i)</span>:</span></span><br><span class="line">    li.append(i)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'say hi'</span>,li</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    p = Process(target=foo,args=(i,))</span><br><span class="line">    p.start()</span><br><span class="line">     </span><br><span class="line"><span class="keyword">print</span> <span class="string">'ending'</span>,li</span><br></pre></td></tr></table></figure><p><strong>使用特殊的数据类型，来进行穿墙：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">默认的进程之间相互是独立，如果想让进程之间数据共享，就得有个特殊的数据结构，这个数据结构就可以理解为他有穿墙的功能</span><br><span class="line">如果你能穿墙的话两边就都可以使用了</span><br><span class="line">使用了<span class="number">3</span>种方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一种方法：</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过特殊的数据结构：数组（Array）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Array</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个只包含数字类型的数组（python中叫列表）</span></span><br><span class="line"><span class="comment">#并且数组是不可变的，在C，或其他语言中，数组是不可变的，之后再python中数组（列表）是可以变得</span></span><br><span class="line"><span class="comment">#当然其他语言中也提供可变的数组</span></span><br><span class="line"><span class="comment">#在C语言中数组和字符串是一样的，如果定义一个列表，如果可以增加，那么我需要在你内存地址后面再开辟一块空间，那我给你预留多少呢？</span></span><br><span class="line"><span class="comment">#在python中的list可能用链表来做的，我记录了你前面和后面是谁。   列表不是连续的，数组是连续的</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">上面不是列表是“数组"数组是不可变的，附加内容是为了更好的理解数组！</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">temp = Array(<span class="string">'i'</span>, [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>]) <span class="comment">#这里的i是C语言中的数据结构，通过他来定义你要共享的内容的类型！点进去看~</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Foo</span><span class="params">(i)</span>:</span></span><br><span class="line">    temp[i] = <span class="number">100</span>+i</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> temp:</span><br><span class="line">        <span class="keyword">print</span> i,<span class="string">'-----&gt;'</span>,item</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    p = Process(target=Foo,args=(i,))</span><br><span class="line">    p.start()</span><br><span class="line">    </span><br><span class="line">第二种方法：</span><br><span class="line"><span class="comment">#方法二：manage.dict()共享数据</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Manager  <span class="comment">#这个特殊的数据类型Manager</span></span><br><span class="line"> </span><br><span class="line">manage = Manager()</span><br><span class="line">dic = manage.dict() <span class="comment">#这里调用的时候，使用字典，这个字典和咱们python使用方法是一样的！</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Foo</span><span class="params">(i)</span>:</span></span><br><span class="line">    dic[i] = <span class="number">100</span>+i</span><br><span class="line">    <span class="keyword">print</span> dic.values()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    p = Process(target=Foo,args=(i,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><p><strong>OK那么问题来了，既然进程之间可以进行共享数据，如果多个进程同时修改这个数据是不是就会造成脏数据？是不是就得需要锁！</strong></p><p>进程的锁和线程的锁使用方式是非常一样的知识他们是用的类是在不同地方的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Array, RLock</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Foo</span><span class="params">(lock,temp,i)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    将第0个数加100</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    temp[<span class="number">0</span>] = <span class="number">100</span>+i</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> temp:</span><br><span class="line">        <span class="keyword">print</span> i,<span class="string">'-----&gt;'</span>,item</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line">lock = RLock()</span><br><span class="line">temp = Array(<span class="string">'i'</span>, [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    p = Process(target=Foo,args=(lock,temp,i,))</span><br><span class="line">    p.start()</span><br></pre></td></tr></table></figure><p> <strong>进程池</strong></p><p>进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进进程，那么程序就会等待，直到进程池中有可用进程为止。</p><p>进程池中有两个方法：</p><ul><li>apply</li><li>apply_async</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span>  multiprocessing <span class="keyword">import</span> Process,Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Foo</span><span class="params">(i)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">100</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Bar</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> arg</span><br><span class="line">  </span><br><span class="line">pool = Pool(<span class="number">5</span>) <span class="comment">#创建一个进程池</span></span><br><span class="line"><span class="comment">#print pool.apply(Foo,(1,))#去进程池里去申请一个进程去执行Foo方法</span></span><br><span class="line"><span class="comment">#print pool.apply_async(func =Foo, args=(1,)).get()</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    pool.apply_async(func=Foo, args=(i,),callback=Bar)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">print</span> <span class="string">'end'</span></span><br><span class="line">pool.close()</span><br><span class="line">pool.join()<span class="comment">#进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">apply 主动的去执行</span></span><br><span class="line"><span class="string">pool.apply_async(func=Foo, args=(i,),callback=Bar) 相当于异步，当申请一个线程之后，执行FOO方法就不管了，执行完之后就在执行callback ，当你执行完之后，在执行一个方法告诉我执行完了</span></span><br><span class="line"><span class="string">callback 有个函数，这个函数就是操作的Foo函数的返回值！</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>首先要明确，线程和进程都是系统帮咱们开辟的，不管是thread还是process他内部都是调用的系统的API<br>而对于协程来说它和系统毫无关系！<br>他就和程序员有关系，对于线程和进程来说，调度是由CPU来决定调度的！<br>对于协程来说，程序员就是上帝，你想让谁执行到哪里他就执行到哪里</p><p>协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。</p><p>适用场景：其实在其他语言中，协程的其实是意义不大的多线程即可已解决I/O的问题，但是在python因为他有GIL（Global Interpreter Lock 全局解释器锁 ）在同一时间只有一个线程在工作，所以：如果一个线程里面I/O操作特别多，协程就比较适用</p><p><strong>greenlet</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">收先要明确，线程和进程都是系统帮咱们开辟的，不管是thread还是process他内部都是调用的系统的API</span><br><span class="line">而对于协程来说它和系统毫无关系！</span><br><span class="line">他就和程序员有关系，对于线程和进程来说，是不是有CPU来决定调度的！</span><br><span class="line">对于协程来说，程序员就是上帝，你想让谁执行到哪里他就执行到哪里</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="number">12</span></span><br><span class="line">    gr2.switch()<span class="comment">#切换到协程2执行</span></span><br><span class="line">    <span class="keyword">print</span> <span class="number">34</span> <span class="comment">#2切回来之后，在这里和yield类似</span></span><br><span class="line">    gr2.switch() </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="number">56</span></span><br><span class="line">    gr1.switch()<span class="comment">#上面执行了一句，在切换到协程1里去了</span></span><br><span class="line">    <span class="keyword">print</span> <span class="number">78</span></span><br><span class="line"> </span><br><span class="line">gr1 = greenlet(test1) <span class="comment">#创建了一个协程</span></span><br><span class="line">gr2 = greenlet(test2)</span><br><span class="line"></span><br><span class="line">gr1.switch() <span class="comment">#执行test1 </span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">比I/O操作，如果10个I/O，我程序从上往下执行，如果同时发出去了10个I/O操作，那么返回的结果如果同时回来了2个</span></span><br><span class="line"><span class="string">，是不是就节省了很多时间？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果一个线程里面I/O操作特别多，使用协程是不是就非常适用了！</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果一个线程访问URL通过协程来做，协程告诉它你去请求吧，然后继续执行，但是如果不用协程就得等待第一个请求完毕之后返回之后才</span></span><br><span class="line"><span class="string">继续下一个请求。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">协程：把一个线程分成了多个协程操作，每个协程做操作</span></span><br><span class="line"><span class="string">多线程：是把每一个操作，分为多个线程做操作，但是python中，在同一时刻只能有一个线程操作，并且有上下文切换。但是如果上下文切换非常频繁的话</span></span><br><span class="line"><span class="string">是非常耗时的，但对于协程切换就非常轻便了~</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>协程就是对线程的分片，上面的例子需要手动操作可能用处不是很大了解原理，看下面的例子：</p><p>上面的<strong>greenlet</strong>是需要认为的制定调度顺序的，所以又出了一个<strong>gevent</strong>他是对greenlet功能进行封装</p><p> 遇到I/O自动切换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey; monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'GET: %s'</span> % url)</span><br><span class="line">    resp = urllib2.urlopen(url) <span class="comment">#当遇到I/O操作的时候就会调用协程操作，然后继续往下走，然后这个协程就卡在这里等待数据的返回</span></span><br><span class="line">    data = resp.read()</span><br><span class="line">    print(<span class="string">'%d bytes received from %s.'</span> % (len(data), url))</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">        gevent.spawn(f, <span class="string">'https://www.python.org/'</span>),  <span class="comment">#这里的f是调用这个方法，第二个是调用方的参数</span></span><br><span class="line">        gevent.spawn(f, <span class="string">'https://www.yahoo.com/'</span>),</span><br><span class="line">        gevent.spawn(f, <span class="string">'https://github.com/'</span>),</span><br><span class="line">]) </span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">gevent.spawn(f, 'https://www.python.org/'),  #这里的f是调用这个方法，第二个是调用方的参数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当函数f里的代码遇到I/O操作的时候，函数就卡在哪里等待数据的返回，但是协程不会等待而是继续操作!</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Socket-Server模块&quot;&gt;&lt;a href=&quot;#Socket-Server模块&quot; class=&quot;headerlink&quot; title=&quot;Socket Server模块&quot;&gt;&lt;/a&gt;Socket Server模块&lt;/h2&gt;&lt;p&gt;SocketServer内部使用 I
      
    
    </summary>
    
      <category term="运维开发" scheme="http://wandouduoduo.github.io/categories/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/"/>
    
      <category term="语言积累" scheme="http://wandouduoduo.github.io/categories/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/%E8%AF%AD%E8%A8%80%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="Python" scheme="http://wandouduoduo.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java定时器设定详解</title>
    <link href="http://wandouduoduo.github.io/articles/d0e68aab.html"/>
    <id>http://wandouduoduo.github.io/articles/d0e68aab.html</id>
    <published>2019-07-29T01:29:39.000Z</published>
    <updated>2019-08-07T02:06:43.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文通过实例详细介绍了Java定时和linux通用的crontab之间的差异。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>这些星号由左到右按顺序代表 ： * * * * * * *</p><p>格式: [秒] [分] [小时] [日] [月] [周] [年]</p><p>序号说明是否必填 允许填写的值 允许的通配符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1 秒 是 0-59 , - * /</span><br><span class="line"></span><br><span class="line">2 分 是 0-59 , - * /</span><br><span class="line"></span><br><span class="line">3 小时 是 0-23 , - * /</span><br><span class="line"></span><br><span class="line">4 日 是 1-31 , - * ? / L W</span><br><span class="line"></span><br><span class="line">5 月 是 1-12 or JAN-DEC , - * /</span><br><span class="line"></span><br><span class="line">6 周 是 1-7 or SUN-SAT , - * ? / L #</span><br><span class="line"></span><br><span class="line">7 年 否 empty 或 1970-2099 , - * /</span><br></pre></td></tr></table></figure><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">* 表示所有值. 例如:在分的字段上设置 "*",表示每一分钟都会触发。</span><br><span class="line"></span><br><span class="line">? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为"?" 具体设置为 0 0 0 10 * ?</span><br><span class="line"></span><br><span class="line">- 表示区间。例如 在小时上设置 "10-12",表示 10,11,12点都会触发。</span><br><span class="line"></span><br><span class="line">, 表示指定多个值，例如在周字段上设置 "MON,WED,FRI" 表示周一，周三和周五触发</span><br><span class="line"></span><br><span class="line">/ 用于递增触发。如在秒上面设置"5/15" 表示从5秒开始，每增15秒触发(5,20,35,50)。在月字段上设置'1/3'所示每月1号开始，每隔三天触发一次。一般不写的话，默认递增为基本单位，如1分钟，1秒钟</span><br><span class="line"></span><br><span class="line">L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于"7"或"SAT"。如果在"L"前加上数字，则表示该数据的最后一个。例如在周字段上设置"6L"这样的格式,则表示“本月最后一个星期五"</span><br><span class="line"></span><br><span class="line">W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上设置"15W"，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 "1W",它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，"W"前只能设置具体的数字,不允许区间"-").</span><br><span class="line"></span><br><span class="line">小提示</span><br><span class="line">'L'和 'W'可以一组合使用。如果在日字段上设置"LW",则表示在本月的最后一个工作日触发(一般指发工资 )</span><br><span class="line"></span><br><span class="line">\# 序号(表示每月的第几个周几)，例如在周字段上设置"6#3"表示在每月的第三个周六.注意如果指定"#5",正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了)</span><br><span class="line"></span><br><span class="line">小提示</span><br><span class="line"></span><br><span class="line">周字段的设置，若使用英文字母是不区分大小写的 MON 与mon相同.</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0 0 12 * * ? 每天12点触发</span><br><span class="line"></span><br><span class="line">0 15 10 ? * * 每天10点15分触发</span><br><span class="line"></span><br><span class="line">0 15 10 * * ? 每天10点15分触发</span><br><span class="line"></span><br><span class="line">0 15 10 * * ? * 每天10点15分触发</span><br><span class="line"></span><br><span class="line">0 15 10 * * ? 2005 2005年每天10点15分触发</span><br><span class="line"></span><br><span class="line">0 * 14 * * ? 每天下午的 2点到2点59分每分触发</span><br><span class="line"></span><br><span class="line">0 0/5 14 * * ? 每天下午的 2点到2点59分(整点开始，每隔5分触发)</span><br><span class="line"></span><br><span class="line">0 0/5 14,18 * * ? 每天下午的 2点到2点59分(整点开始，每隔5分触发)以及每天下午的 18点到18点59分(整点开始，每隔5分触发)</span><br><span class="line"></span><br><span class="line">0 0-5 14 * * ? 每天下午的 2点到2点05分每分触发</span><br><span class="line"></span><br><span class="line">0 10,44 14 ? 3 WED 3月分每周三下午的 2点10分和2点44分触发 （特殊情况，在一个时间设置里，执行两次或 两次以上的情况）</span><br><span class="line"></span><br><span class="line">0 59 2 ? * FRI 每周5凌晨2点59分触发；</span><br><span class="line"></span><br><span class="line">0 15 10 ? * MON-FRI 从周一到周五每天上午的10点15分触发</span><br><span class="line"></span><br><span class="line">0 15 10 15 * ? 每月15号上午10点15分触发</span><br><span class="line"></span><br><span class="line">0 15 10 L * ? 每月最后一天的10点15分触发</span><br><span class="line"></span><br><span class="line">0 15 10 ? * 6L 每月最后一周的星期五的10点15分触发</span><br><span class="line"></span><br><span class="line">0 15 10 ? * 6L 2002-2005 从2002年到2005年每月最后一周的星期五的10点15分触发</span><br><span class="line"></span><br><span class="line">0 15 10 ? * 6#3 每月的第三周的星期五开始触发</span><br><span class="line"></span><br><span class="line">0 0 12 1/5 * ? 每月的第一个中午开始每隔5天触发一次</span><br><span class="line"></span><br><span class="line">0 11 11 11 11 ? 每年的11月11号 11点11分触发(光棍节)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;本文通过实例详细介绍了Java定时和linux通用的crontab之间的差异。&lt;/p&gt;
    
    </summary>
    
      <category term="应用运维" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Java" scheme="http://wandouduoduo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>lsof文件句柄工具</title>
    <link href="http://wandouduoduo.github.io/articles/6915627d.html"/>
    <id>http://wandouduoduo.github.io/articles/6915627d.html</id>
    <published>2019-07-29T01:25:02.000Z</published>
    <updated>2019-08-07T02:06:43.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在linux环境下，一切皆文件，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件，如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，文件描述符提供了大量关于这个应用程序本身的信息。</p><h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> -a 列出被打开的文件的进程列表</span><br><span class="line">-c&lt;进程名&gt; 列出指定进程所打开的文件</span><br><span class="line">-g 列出GID号进程详情</span><br><span class="line">-d&lt;文件号&gt; 列出占用该文件号的进程</span><br><span class="line">+d&lt;目录&gt; 列出目录下被打开的文件</span><br><span class="line">+D&lt;目录&gt; 递归列出目录下被打开的文件</span><br><span class="line">-n&lt;目录&gt; 列出使用NFS的文件</span><br><span class="line">-i&lt;条件&gt; 列出符合条件的进程。（4、6、协议、:端口、 @ip ）</span><br><span class="line">-p&lt;进程号&gt; 列出指定进程号所打开的文件</span><br><span class="line">-u 列出UID号进程详情</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h4 id="文件被哪些进程打开了"><a href="#文件被哪些进程打开了" class="headerlink" title="文件被哪些进程打开了"></a>文件被哪些进程打开了</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> root@lzjun:~# lsof -a /var/lib/mysql/mysql/slow_log.CSV</span><br><span class="line">COMMAND   PID  USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME</span><br><span class="line">mysqld  29363 mysql   63r   REG  253,1        0 263979 /var/lib/mysql/mysql/slow_log.CSV</span><br></pre></td></tr></table></figure><h4 id="列出用户打开的文件"><a href="#列出用户打开的文件" class="headerlink" title="列出用户打开的文件"></a>列出用户打开的文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> root@lzjun:~# lsof -u root | more</span><br><span class="line">COMMAND     PID USER   FD      TYPE             DEVICE SIZE/OFF       NODE NAME</span><br><span class="line">init          1 root  cwd       DIR              253,1     4096          2 /</span><br><span class="line">init          1 root  rtd       DIR              253,1     4096          2 /</span><br><span class="line">init          1 root  txt       REG              253,1   167192    1048737 /sbin/init</span><br></pre></td></tr></table></figure><h4 id="列出程序（command）打开了哪些文件"><a href="#列出程序（command）打开了哪些文件" class="headerlink" title="列出程序（command）打开了哪些文件"></a>列出程序（command）打开了哪些文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> root@lzjun:~# lsof -c python</span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME</span><br><span class="line">python  32280 root  rtd    DIR  253,1     4096      2 /</span><br><span class="line">python  32280 root  mem    REG  253,1    52120 927846 /lib/x86_64-linux-gnu/libnss_files-2.15.so</span><br><span class="line">python  32280 root  DEL    REG  253,1          263953 /usr/lib/python2.7/lib-dynload/_multiprocessing.so</span><br></pre></td></tr></table></figure><h4 id="根据进程号列出该进程打开的文件"><a href="#根据进程号列出该进程打开的文件" class="headerlink" title="根据进程号列出该进程打开的文件"></a>根据进程号列出该进程打开的文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> root@lzjun:~# lsof -p 31370  #nginx的进程号</span><br><span class="line">COMMAND   PID     USER   FD   TYPE             DEVICE SIZE/OFF    NODE NAME</span><br><span class="line">nginx   31370 www-data  cwd    DIR              253,1     4096       2 /</span><br><span class="line">nginx   31370 www-data  rtd    DIR              253,1     4096       2 /</span><br><span class="line">nginx   31370 www-data  txt    REG              253,1   843688 1186644 /usr/sbin/nginx</span><br></pre></td></tr></table></figure><h4 id="查看所有网络连接，包括tcp，udp，ipv4-ipv6的连接（网络连接也是文件）"><a href="#查看所有网络连接，包括tcp，udp，ipv4-ipv6的连接（网络连接也是文件）" class="headerlink" title="查看所有网络连接，包括tcp，udp，ipv4,ipv6的连接（网络连接也是文件）"></a>查看所有网络连接，包括tcp，udp，ipv4,ipv6的连接（网络连接也是文件）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> root@lzjun:~# lsof -i</span><br><span class="line">COMMAND    PID     USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME</span><br><span class="line">pptpd      975     root    6u  IPv4     8836      0t0  TCP *:1723 (LISTEN)</span><br><span class="line">ssserver  7366     root    4u  IPv4   100096      0t0  TCP *:8388 (LISTEN)</span><br><span class="line">ssserver  7366     root    5u  IPv4   100097      0t0  UDP *:8388</span><br><span class="line">ssserver  7366     root    7u  IPv4   100098      0t0  UDP *:57935</span><br></pre></td></tr></table></figure><h4 id="查看某个端口打开的文件（socket-连接）"><a href="#查看某个端口打开的文件（socket-连接）" class="headerlink" title="查看某个端口打开的文件（socket 连接）"></a>查看某个端口打开的文件（socket 连接）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> root@lzjun:~# lsof -i :80</span><br><span class="line">COMMAND   PID     USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME</span><br><span class="line">nginx   31369     root    6u  IPv4 8882096      0t0  TCP *:http (LISTEN)</span><br></pre></td></tr></table></figure><h4 id="查看所有TCP连接"><a href="#查看所有TCP连接" class="headerlink" title="查看所有TCP连接"></a>查看所有TCP连接</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -n -P -i TCP -s TCP:LISTEN</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;在linux环境下，一切皆文件，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件，如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，文件描述符提供了大量关于这个应用程序本身的信息。&lt;/p&gt;
&lt;h2 id=&quot;参数：&quot;&gt;&lt;a href=&quot;#参数：&quot; class=&quot;headerlink&quot; title=&quot;参数：&quot;&gt;&lt;/a&gt;参数：&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; -a 列出被打开的文件的进程列表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-c&amp;lt;进程名&amp;gt; 列出指定进程所打开的文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-g 列出GID号进程详情&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-d&amp;lt;文件号&amp;gt; 列出占用该文件号的进程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+d&amp;lt;目录&amp;gt; 列出目录下被打开的文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+D&amp;lt;目录&amp;gt; 递归列出目录下被打开的文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-n&amp;lt;目录&amp;gt; 列出使用NFS的文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-i&amp;lt;条件&amp;gt; 列出符合条件的进程。（4、6、协议、:端口、 @ip ）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-p&amp;lt;进程号&amp;gt; 列出指定进程号所打开的文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-u 列出UID号进程详情&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="应用运维" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Linux" scheme="http://wandouduoduo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>tmux参考手册</title>
    <link href="http://wandouduoduo.github.io/articles/a5e32f5.html"/>
    <id>http://wandouduoduo.github.io/articles/a5e32f5.html</id>
    <published>2019-07-29T01:21:26.000Z</published>
    <updated>2019-08-07T02:06:43.843Z</updated>
    
    <content type="html"><![CDATA[<p>tmux可以在一个屏幕中创建多个session，window，pane等，可以从一个屏幕中分离并继续在后台运行，以后可以重新连接。</p><a id="more"></a><h3 id="Session控制"><a href="#Session控制" class="headerlink" title="Session控制:"></a>Session控制:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`#直接创建session``tmux`` ``#查看session``tmux ``ls`` ``#创建名字为wkl39883的session``tmux new -s wkl39883`` ``#attach到名字为wkl39883的session``tmux a -t wkl39883`` ``#attch到session, 同时踢掉其他所有attac``tmux a -t wkl39883 -d`</span><br></pre></td></tr></table></figure><p><img src="file:///var/folders/13/5_qy4sz928nbrf6spnjzf5kr0000gn/T/WizNote/17de5170-40f4-494a-8bb4-680a07f210f9/index_files/52787115.png" alt="img"></p><p><img src="file:///var/folders/13/5_qy4sz928nbrf6spnjzf5kr0000gn/T/WizNote/17de5170-40f4-494a-8bb4-680a07f210f9/index_files/52798175.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tmux可以在一个屏幕中创建多个session，window，pane等，可以从一个屏幕中分离并继续在后台运行，以后可以重新连接。&lt;/p&gt;
    
    </summary>
    
      <category term="应用运维" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Linux" scheme="http://wandouduoduo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>LDAP部署和第三方服务接入</title>
    <link href="http://wandouduoduo.github.io/articles/543cefa7.html"/>
    <id>http://wandouduoduo.github.io/articles/543cefa7.html</id>
    <published>2019-07-25T08:17:53.000Z</published>
    <updated>2019-08-07T02:06:43.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LDAP部署"><a href="#LDAP部署" class="headerlink" title="LDAP部署"></a>LDAP部署</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>可以通过以下三句话快速的认识一下LDAP：</p><ol><li>LDAP：Lightweight Directory Access Protocol，轻量目录访问协议。</li><li>LDAP服务是一个为只读（查询、浏览、搜索）访问而优化的非关系型数据库，呈树状结构组织数据。</li><li>LDAP主要用做用户信息查询（如邮箱、电话等）或对各种服务访问做后台认证以及用户数据权限管控。</li></ol><h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><ul><li>DC：domain component一般为公司名，例如：dc=163,dc=com</li><li>OU：organization unit为组织单元，最多可以有四级，每级最长32个字符，可以为中文</li><li>CN：common name为用户名或者服务器名，最长可以到80个字符，可以为中文</li><li>DN：distinguished name为一条LDAP记录项的名字，有唯一性，例如：dc:”cn=admin,ou=developer,dc=163,dc=com”</li></ul><h4 id="图形示例"><a href="#图形示例" class="headerlink" title="图形示例"></a>图形示例</h4><p>上边来了一堆的名词解释，看的云里雾里，还不是很明白，怎么跟自己的组织架构对应起来呢？看看下边的图是不是清晰明了</p><p><img src="/articles/543cefa7/1.png" alt="img"></p><a id="more"></a><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>部署环境：Debian 8.4</p><p>1.安装OpenLDAP,OpenLDAP服务端程序叫slapd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> apt-get install -y slapd</span></span><br></pre></td></tr></table></figure><p>2.安装完成之后，会自动生成一个OpenLDAP的系统账号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /etc/passwd</span></span><br><span class="line">openldap:x:110:115:OpenLDAP Server Account,,,:/var/lib/ldap:/bin/false</span><br></pre></td></tr></table></figure><p>3.生成OpenLDAP管理员账号的密码（后边修改配置文件需要使用）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> slappasswd</span></span><br><span class="line">New password: </span><br><span class="line">Re-enter new password: </span><br><span class="line">&#123;SSHA&#125;EcAoXeGab5g8y2Y03EmH3+Zc3hJaHp7F</span><br></pre></td></tr></table></figure><p>4.新建OpenLDAP配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cp /usr/share/slapd/slapd.conf /etc/ldap/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置文件中有很多@xxx@的配置替换为真实配置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> slaptest -f /etc/ldap/slapd.conf </span></span><br><span class="line">5ad9b19d /etc/ldap/slapd.conf: line 105: rootdn is always granted unlimited privileges.</span><br><span class="line">5ad9b19d /etc/ldap/slapd.conf: line 122: rootdn is always granted unlimited privileges.</span><br><span class="line">config file testing succeeded</span><br></pre></td></tr></table></figure><p>配置文件重要参数说明（需要自己修改的，其他未提到的可以不修改）：</p><ul><li><code>database bdb</code>：定义使用的后端数据存储格式，数据库默认采用了berkeley db，其后可以跟的值有bdb、ldbm、passwd、shell。bdb指使用Berkley DB 4数据库</li><li><code>suffix &quot;dc=163,dc=com&quot;</code>：suffix是”LDAP基准名”，它是LDAP名字空间在这里的根。设置想要创建的子树的根DN</li><li><code>rootdn &quot;cn=admin,dc=163,dc=com&quot;</code>：设置管理LDAP目录的超级用户的DN。这个用户名不要出现在/etc/passwd文件里</li><li><code>rootpw {SSHA}EcAoXeGab5g8y2Y03EmH3+Zc3hJaHp7F</code>：设置这个数据库的超级用户的口令验证方式。也就是上边rootdn设置的用户的密码。一定要用加密的口令存储，可以使用的加密方式有：CRYPT、MD5、SMD5、SHA和SSHA，<strong>就是我们第三步生成的密码</strong></li><li><code>directory /var/lib/ldap</code>：设置LDAP数据库和索引文件所在的目录</li><li><code>access to</code>：权限配置下边详细说明</li></ul><p>5.删除原配置，生成新配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rm -rf /etc/ldap/slapd.d/*</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> slaptest -f /etc/ldap/slapd.conf -F /etc/ldap/slapd.d/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给新生成的配置文件赋予OpenLdap的权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> chown -R openldap.openldap /etc/ldap/slapd.d/</span></span><br></pre></td></tr></table></figure><p>6.重启OpenLdap</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /etc/init.d/slapd restart</span></span><br></pre></td></tr></table></figure><h2 id="ACL权限控制"><a href="#ACL权限控制" class="headerlink" title="ACL权限控制"></a>ACL权限控制</h2><p>ACL访问指令的格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">access to [what]</span><br><span class="line">    by [who] [control]</span><br></pre></td></tr></table></figure><p>简单解释：通过access to约束我们访问的范围（what），通过by设定哪个用户（who）有什么权限（control）</p><p>ACL的详细配置还是比较复杂的，可以看下下边参考文档的第三篇，写的比较详细，这里都不再赘述。</p><h3 id="线上ACL控制配置解析"><a href="#线上ACL控制配置解析" class="headerlink" title="线上ACL控制配置解析"></a>线上ACL控制配置解析</h3><p>为了用户能够自主修改密码，部署了lam给用户使用（见下文lam介绍）。希望能达到的效果是：</p><ol><li>管理员能够有全部权限，包含新建用户，修改用户属性，充值用户密码等</li><li>普通用户只能修改自己的密码，别的权限都没有</li></ol><p>配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> access to attrs=userPassword通过属性找到访问范围密码,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 超级管理员也就是我们ldap配置文件里写的rootdn：<span class="string">"cn=admin,dc=163,dc=com"</span>有写(write)权限；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 由于管理员可能不止一个，我创建了个管理员组<span class="string">"ou=Admin,dc=163,dc=com"</span>把管理员统一都放到这个组下，管理员组下的所有用户（dn.children）有写权限；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 匿名用户(anonymous)要通过验证(auth);</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自己(self)有对自己密码的写（write）权限，其他人(*)都没有权限(none).</span></span><br><span class="line">access to attrs=userPassword,shadowLastChange</span><br><span class="line">        by dn="cn=admin,dc=163,dc=com" write</span><br><span class="line">        by dn.children="ou=Admin,dc=163,dc=com" write</span><br><span class="line">        by anonymous auth</span><br><span class="line">        by self write</span><br><span class="line">        by * none</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> access to * 所有其他属性，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 超级管理员rootdn：<span class="string">"cn=admin,dc=163,dc=com"</span>有写(write)权限；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 管理员<span class="string">"ou=Admin,dc=163,dc=com"</span>成员有写(write)权限；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其他人(*)只有读(<span class="built_in">read</span>)权限</span></span><br><span class="line">access to *</span><br><span class="line">        by dn="cn=admin,dc=163,dc=com" write</span><br><span class="line">        by dn.children="ou=Admin,dc=163,dc=com" write</span><br><span class="line">        by * read</span><br></pre></td></tr></table></figure><h2 id="备份和还原"><a href="#备份和还原" class="headerlink" title="备份和还原"></a>备份和还原</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ldapsearch -x -b <span class="string">"dc=163,dc=com"</span> -D <span class="string">"uid=authz,ou=Public,dc=163,dc=com"</span> -w <span class="string">"CzfdX629K7"</span> &gt; ldap.20180626.ldif</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-x</code>：进行简单的验证</li><li><code>-D</code>：用来绑定服务器的DN</li><li><code>-w</code>：绑定DN的密码</li><li><code>-b</code>：要查询的根节点<br>authz账号要有<code>&quot;dc=163,dc=com&quot;</code>的查询权限</li></ul><h3 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ldapadd -x -c -D <span class="string">"cn=admin,dc=163,dc=com"</span> -w <span class="string">"smile"</span> -f ldap.20180626.ldif</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-c</code>：出错后继续执行程序不终止，默认出错即停止</li><li><code>-f</code>：从文件内读取信息还原，而不是标准输入<br>还原的DN最好为管理员账号，至少也要有要LDAP的写入权限</li></ul><h2 id="web管理工具"><a href="#web管理工具" class="headerlink" title="web管理工具"></a>web管理工具</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1.安装ldap-account-management</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> apt-get install ldap-account-manager</span></span><br></pre></td></tr></table></figure><p>2.浏览器访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip/lam</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>lam的所有配置都可以在web端配置，不需要去服务器上修改一行代码，这个太好用了。</p><ol><li><p>浏览器访问后进入登录页面，我们点击右上角”LAM configuratrion”来在线编辑配置文件</p><p><img src="/articles/543cefa7/2.png" alt="img"></p></li><li><p>看到如下页面有两个选项：”Edit general settings”来编辑通用配置，默认密码lam，进入之后能配置密码策略、日志、管理员密码，最重要的是更新掉管理员密码，这个在后边”Manage server profiles”管理的时候需要提供；”Edit server profiles”来编辑服务器配置，我们先来编辑服务器配置</p><p><img src="/articles/543cefa7/3.png" alt="img"></p></li><li><p>进入如下页面，输入默认密码lam即可编辑配置，这里要说明一下的是红框标注的”Manage server profiles”可以对服务器的配置文件进行配置，例如增加、删除配置文件、配置文件重命名，最重要的是可以设置配置文件密码（也就是我们刚输入的密码lam，但修改密码需要管理员密码，后边配置）</p><p><img src="/articles/543cefa7/4.png" alt="img"></p></li><li><p>输入密码lam后就正式进入服务器配置页，看到第一个标签”General setting”，（可以先改下语言简体中文保存，整站就给汉化啦，英文渣渣看起来就非常方便了），基本配置都看的很清晰了，主要是Tree suffix配置为自己的DC可以了</p><p><img src="/articles/543cefa7/5.png" alt="img"></p></li><li><p>接着来看这个页面，”security settings”非常重要，配置以何种方式登录web控制台，默认为Fixed list模式，就是下边列表里配置的dn可以登录，我们LDAP里还没有任何一个账号（当我们创建了账号之后可以选择”LDAP serch”的模式，让普通账号也能登录以修改自己的密码），这里要选择fixed list模式并配置为我们LDAP的rootdn，设置一个密码登录之后创建账号等操作</p><p><img src="/articles/543cefa7/6.png" alt="img"></p></li><li><p>接下来就是”Account types”标签页的配置，这里配置我们登录web控制显示的标签，我这里只需要他显示用户，就把Group之类的都删除了，保留了User</p><p><img src="/articles/543cefa7/7.png" alt="img"></p></li><li><p>“Modules”页面配置上一个具体每个account type显示的模块</p><p><img src="/articles/543cefa7/8.png" alt="img"></p></li><li><p>“Models setting”页面配置models具体要显示的内容，不得不说配置非常详细</p><p><img src="/articles/543cefa7/9.png" alt="img"></p></li><li><p>经过上边的配置就可以进入控制台新建账号了，新建账号之前一个有用的操作是修改用户的默认RDN标致为uid，更高位置在登录web控制台后右上角配置文件编辑器里边</p><p><img src="/articles/543cefa7/10.png" alt="img"></p></li><li><p>基本配置完成，可以开始使用了，中文界面比较清晰，无需过多解释啦。</p></li></ol><h1 id="SVN集成OpenLDAP认证"><a href="#SVN集成OpenLDAP认证" class="headerlink" title="SVN集成OpenLDAP认证"></a>SVN集成OpenLDAP认证</h1><ul><li>系统环境：Debian8.4</li><li>svn部署环境：Apache2.4 + Subversion</li></ul><ol><li>Apache开启LDAP相关模块</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> a2enmod ldap</span></span><br><span class="line">Enabling module ldap.</span><br><span class="line">To activate the new configuration, you need to run:</span><br><span class="line">  service apache2 restart</span><br><span class="line"><span class="meta">#</span><span class="bash"> a2enmod authnz_ldap</span></span><br><span class="line">Considering dependency ldap for authnz_ldap:</span><br><span class="line">Module ldap already enabled</span><br><span class="line">Enabling module authnz_ldap.</span><br><span class="line">To activate the new configuration, you need to run:</span><br><span class="line">  service apache2 restart</span><br></pre></td></tr></table></figure><ol><li>修改vhost配置文件，添加对ldap的支持</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;Virtualhost *:8088&gt;</span><br><span class="line">    DocumentRoot /home/svn/repos/</span><br><span class="line">    ServerName svn.domain.com</span><br><span class="line"></span><br><span class="line">    &lt;Location /ne/&gt;</span><br><span class="line">        DAV svn</span><br><span class="line">        SVNListParentPath on</span><br><span class="line">        SVNParentPath &quot;/home/svn/repos&quot;</span><br><span class="line"></span><br><span class="line">        AuthType Basic</span><br><span class="line">        AuthName &quot;Private Subversion Repository&quot;</span><br><span class="line"></span><br><span class="line">        #AuthUserFile &quot;/etc/subversion/dav_svn.passwd&quot;</span><br><span class="line">        AuthzSVNAccessFile &quot;/etc/subversion/dav_svn.authz&quot;</span><br><span class="line"></span><br><span class="line">        # use LDAP auth</span><br><span class="line">        AuthBasicProvider ldap</span><br><span class="line">        AuthLDAPBindAuthoritative on</span><br><span class="line">        AuthLDAPURL &quot;ldap://ldap.domain.com/dc=domain,dc=com?uid?sub?(objectclass=*)&quot;</span><br><span class="line">        AuthLDAPBindDN &quot;uid=authz,ou=Public,dc=domain,dc=com&quot;</span><br><span class="line">        AuthLDAPBindPassword &quot;CzfdX629K7&quot;</span><br><span class="line"></span><br><span class="line">        Require ldap-user</span><br><span class="line"></span><br><span class="line">    &lt;/Location&gt;</span><br><span class="line">&lt;/Virtualhost&gt;</span><br></pre></td></tr></table></figure><h2 id="主要LDAP配置文件详解："><a href="#主要LDAP配置文件详解：" class="headerlink" title="主要LDAP配置文件详解："></a>主要LDAP配置文件详解：</h2><p><strong>AuthType</strong>：验证类型，Basic使用账号密码验证</p><p><strong>AuthName</strong>：提示字符串</p><p><strong>AuthBasicProvider</strong>：使用ldap验证</p><p><strong>AuthLDAPBindAuthoritative</strong>：on表示只要求验证ldap用户，别的不认，off则可以使用svn的账号和ldap混合账号登录</p><ul><li>apache2.2中配置是<code>AuthzLDAPAuthoritative</code>，到2.4中改为了<code>AuthLDAPBindAuthoritative</code></li><li>但在实际应用中发现并么有什么用，设置为off后ldap认证失败也不会去找AuthzSVNAccessFile，或许是我姿势不对，有知道原因的烦请告知</li></ul><p><strong>Require</strong>：ldap-user或valid-user</p><p><strong>AuthLDAPURL | AuthLDAPBindDN | AuthLDAPBindPassword</strong>： 用于查找用户的账号密码，一般设置个只读账号即可</p><ul><li><p>AuthLDAPURL：[协议名称]://[ip地址或者域名]:[端口号]/[baseDN]?[attr]?[scope]?[filter]</p></li><li><ul><li>baseDN：指定开始搜索的节点的名称</li><li>attr：就是用户输入的属性键，默认是“uid”</li><li>scope: one,sub,base，默认是sub</li><li>filter：过滤器，默认是objectclass=*</li></ul></li></ul><h2 id="LDAP服务器认证过程"><a href="#LDAP服务器认证过程" class="headerlink" title="LDAP服务器认证过程"></a>LDAP服务器认证过程</h2><p>可能只看配置文件不能了解LDAP认证的原理，接下来我们详细讨论下LDAP是如何认证的</p><p>客户端(httpd)使用提供的URL(AuthLDAPURL)进行验证的时候，并不是直接验证输入的账号密码，因为LDAP服务器在验证的时候要使用DN(每个节点用户的唯一标识)和密码来进行登陆验证的，但是DN一般来说比较长，诸如:“cn=xxx,ou=xxx,ou=xxx,dc=xxx,dc=xxx”，这种光输入的时候就烦死了，所以要想使用简短的用户名来登陆的时候，一般的做法是在某个节点用户上添加一个属性，比如mobile(手机号),Email(邮箱),user name或者uid(用户名),然后使用这个属性的值来登陆（大部分情况下都用uid，我们也是这么使用的）。</p><p>当用户输入这个属性值（一般uid）和密码的时候，客户端(httpd服务器)先使用AuthLDAPBindDN和AuthLDAPBindPassword作为用户名和密码登陆，根据AuthLDAPURL指定的查询规则来查找用户输入的属性的值有没有，如果查找的条数为0或者大于1，则返回错误，如果查找的条数等于1，则使用查找到的这个条目的DN和用户输入的密码进行登陆验证，成功则成功，失败则失败。</p><p>总结一下LDAP的认证过程分为两部：</p><ol><li>搜索用户是否存在LDAP服务器中：配置文件中配置的AuthLDAPBindDN和AuthLDAPBindPassword两个属性主要目的就是为了登陆LDAP服务器搜索属性(uid)是否只有一条，如果服务器允许匿名访问则这两个配置可以不需要，但一般为了安全性都会关闭LDAP的匿名访问，新建一个只读权限的账号配置到这里即可</li><li>使用用户输入的属性值（uid）和密码进行登陆验证</li></ol><h1 id="GitLab集成OpenLDAP认证"><a href="#GitLab集成OpenLDAP认证" class="headerlink" title="GitLab集成OpenLDAP认证"></a>GitLab集成OpenLDAP认证</h1><h2 id="GitLab配置"><a href="#GitLab配置" class="headerlink" title="GitLab配置"></a>GitLab配置</h2><ol><li>修改配置文件gitlab.yml</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ldap:</span></span><br><span class="line"><span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">servers:</span></span><br><span class="line"><span class="attr">  main:</span> </span><br><span class="line"><span class="attr">    label:</span> <span class="string">'LDAP'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    host:</span> <span class="string">'ldap.domain.com'</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">389</span></span><br><span class="line"><span class="attr">    uid:</span> <span class="string">'uid'</span></span><br><span class="line"><span class="attr">    method:</span> <span class="string">'plain'</span></span><br><span class="line"><span class="attr">    bind_dn:</span> <span class="string">'uid=authz,ou=Public,dc=domain,dc=com'</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">'CzfdX629K7'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    timeout:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    active_directory:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    allow_username_or_email_login:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    block_auto_created_users:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    base:</span> <span class="string">'dc=domain,dc=com'</span></span><br><span class="line"><span class="attr">    user_filter:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><ol><li>重启GitLab服务，看到页面已经有LDAP的登录选项了</li></ol><p><img src="/articles/543cefa7/11.png" alt="img"></p><h2 id="重要配置参数解释"><a href="#重要配置参数解释" class="headerlink" title="重要配置参数解释"></a>重要配置参数解释</h2><p>仔细阅读上一篇svn集成LDAP认证的文章这些参数会更好理解</p><ul><li><strong>host</strong>：LDAP服务器地址</li><li><strong>port</strong>：LDAP服务端口</li><li><strong>uid</strong>：以哪个属性作为验证属性，可以为uid、cn等，我们使用uid</li><li><strong>method</strong>：如果开启了tls或ssl则填写对应的tls或ssl，都没有就填写plain</li><li><strong>bind_dn</strong>：search搜索账号信息的用户完整bind（需要一个有read权限的账号验证通过后搜索用户输入的用户名是否存在）</li><li><strong>password</strong>：bind_dn用户的密码，<code>bind_dn</code>和<code>password</code>两个参数登录LDAP服务器搜索用户</li><li><strong>active_directory</strong>：LDAP服务是否是windows的AD，我们是用的OpenLDAP，这里写false</li><li><strong>allow_username_or_email_login</strong>：是否允许用户名或者邮箱认证，如果是则用户输入用户名或邮箱都可</li><li><strong>base</strong>：从哪个位置搜索用户，例如允许登录GitLab的用户都在ou gitlab里，name这里可以写<code>ou=gitlab,dc=domain,dc=com</code></li><li><strong>filter</strong>：添加过滤属性，例如只过滤employeeType为developer的用户进行认证，可以设置<code>employeeType=developer</code></li></ul><h1 id="Jenkins集成OpenLDAP认证"><a href="#Jenkins集成OpenLDAP认证" class="headerlink" title="Jenkins集成OpenLDAP认证"></a>Jenkins集成OpenLDAP认证</h1><h2 id="安装LDAP插件"><a href="#安装LDAP插件" class="headerlink" title="安装LDAP插件"></a>安装LDAP插件</h2><p>使用LDAP认证需要安装LDAP插件，安装插件有两种方法：</p><h3 id="方法一：后台插件管理里直接安装"><a href="#方法一：后台插件管理里直接安装" class="headerlink" title="方法一：后台插件管理里直接安装"></a>方法一：后台插件管理里直接安装</h3><ul><li>优点：简单方便，不需要考虑插件依赖问题</li><li>缺点：因为网络等各种问题安装不成功</li></ul><p>安装方法：登录Jenkins –&gt; 系统管理 –&gt; 插件管理 –&gt; 可选插件 –&gt; 搜索LDAP –&gt; 选中 –&gt; 直接安装 –&gt; 安装完成重启</p><p><img src="/articles/543cefa7/12.png" alt="img"></p><p>因我们已经安装过了LDAP插件，所有这里搜索不到LDAP插件，只有LDAP Email插件</p><p>如果安装失败，网上也有说在插件管理 –&gt; 高级 –&gt; 升级站点里替换URL为<code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</code>的，但是我替换了之后依然没有成功，最后还是使用方法二安装成功的</p><h3 id="方法二：官网下载安装文件后台上传"><a href="#方法二：官网下载安装文件后台上传" class="headerlink" title="方法二：官网下载安装文件后台上传"></a>方法二：官网下载安装文件后台上传</h3><ul><li>优点：一定可以安装成功的</li><li>缺点：麻烦，要去官网找插件并解决依赖</li></ul><p>插件下载地址：<a href="https://updates.jenkins-ci.org/download/plugins/" target="_blank" rel="noopener">https://updates.jenkins-ci.org/download/plugins/</a></p><p>安装方法：官网下载插件 –&gt; 登录Jenkins –&gt; 系统管理 –&gt; 插件管理 –&gt; 高级 –&gt; 上传插件 –&gt; 选择文件 –&gt; 上传 –&gt; 安装完成后重启</p><p><img src="/articles/543cefa7/13.png" alt="img"></p><p>上传插件安装可能会失败，大部分都是提示你当前插件依赖某些插件，只需要下载全部依赖插件，按照顺序上传安装即可，LDAP插件安装完成后，所有依赖的插件如下：</p><p><img src="/articles/543cefa7/14.png" alt="LDAP依赖插件列表"></p><h2 id="配置LDAP认证"><a href="#配置LDAP认证" class="headerlink" title="配置LDAP认证"></a>配置LDAP认证</h2><p>登录Jenkins –&gt; 系统管理 –&gt; 全局安全配置</p><p><img src="/articles/543cefa7/15.png" alt></p><p>访问控制选择“LDAP”，Server输入LDAP服务器地址，有其他配置可以点击“Advanced Server Configuration…”</p><p><img src="/articles/543cefa7/16.png" alt></p><p><strong>Server</strong>：服务器地址，可以直接填写LDAP服务器的主机名或IP，例如<code>ldap.domain.com</code>（默认端口389），或者<code>ldap.domain.com:1389</code>，如果用了SSL，可以填写<code>ldaps://ldap.domain.com</code>（默认端口636），或者<code>ldaps://ldap.domain.com:1636</code></p><p><img src="/articles/543cefa7/17.png" alt></p><p><strong>root DN</strong>：这里的root DN只是指搜索的根，并非LDAP服务器的root dn。由于LDAP数据库的数据组织结构类似一颗大树，而搜索是递归执行的，理论上，我们如果从子节点（而不是根节点）开始搜索，因为缩小了搜索范围那么就可以获得更高的性能。这里的root DN指的就是这个子节点的DN，当然也可以不填，表示从LDAP的根节点开始搜索</p><p><strong>User search base</strong>：这个配置也是为了缩小LDAP搜索的范围，例如Jenkins系统只允许ou为Admin下的用户才能登陆，那么你这里可以填写<code>ou=Admin</code>，这是一个相对的值，相对于上边的root DN，例如你上边的root DN填写的是<code>dc=domain,dc=com</code>，那么user search base这里填写了<code>ou=Admin</code>，那么登陆用户去LDAP搜索时就只会搜索<code>ou=Admin,dc=domain,dc=com</code>下的用户了</p><p><strong>User search filter</strong>：这个配置定义登陆的“用户名”对应LDAP中的哪个字段，如果你想用LDAP中的uid作为用户名来登录，那么这里可以配置为<code>uid={0}</code>（{0}会自动的替换为用户提交的用户名），如果你想用LDAP中的mail作为用户名来登录，那么这里就需要改为<code>mail={0}</code>。在测试的时候如果提示你<code>user xxx does not exist</code>，而你确定密码输入正确时，就要考虑下输入的用户名是不是这里定义的这个值了</p><p><strong>Group search base</strong>：参考上边<code>User search base</code>解释</p><p><strong>Group search filter</strong>：这个配置允许你将过滤器限制为所需的objectClass来提高搜索性能，也就是说可以只搜索用户属性中包含某个objectClass的用户，这就要求你对你的LDAP足够了解，一般我们也不配置</p><p><strong>Group membership</strong>：没配置，没有详细研究</p><p><strong>Manager DN</strong>：这个配置在你的LDAP服务器不允许匿名访问的情况下用来做认证（详细的认证过程参考文章LDAP落地实战（二）：SVN集成OpenLDAP认证中关于LDAP服务器认证过程的讲解），通常DN为<code>cn=admin,dc=domain,dc=com</code>这样</p><p><strong>Manager Password</strong>：上边配置dn的密码</p><p><strong>Display Name LDAP attribute</strong>：配置用户的显示名称，一般为显示名称就配置为uid，如果你想显示其他字段属性也可以这里配置，例如mail</p><p><strong>Email Address LDAP attribute</strong>：配置用户Email对应的字段属性，一般没有修改过的话都是mail，除非你用其他的字段属性来标识用户邮箱，这里可以配置</p><p>下边还有一些配置如：环境变量Environment Properties、servlet容器代理等，很少用就不多解释了。有一个配置<code>Enable cache</code>可能会用得到，当你的LDAP数据量很大或者LDAP服务器性能较差时，可以开启缓存，配置缓存条数和过期时间，那么在过期时间内新请求优先查找本地缓存认证，认证通过则不会去LDAP服务器请求，以减轻LDAP服务器的压力</p><p><img src="/articles/543cefa7/18.png" alt></p><p>配置完成后可以点击下方的“Test LDAP sttings”来测试配置的准确性</p><p><img src="/articles/543cefa7/19.png" alt></p><p>这里输入的用户名就是你上边配置的<code>User search filter</code>里定义的LDAP中的属性，密码就是LDAP的密码</p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>配置完成并测试通过后就可以用LDAP直接登录了，注意：启用了LDAP登录后将无法再用之前的登录方式（例如本地认证）登录</p><p><img src="/articles/543cefa7/20.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LDAP部署&quot;&gt;&lt;a href=&quot;#LDAP部署&quot; class=&quot;headerlink&quot; title=&quot;LDAP部署&quot;&gt;&lt;/a&gt;LDAP部署&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;可以通过以下三句话快速的认识一下LDAP：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;LDAP：Lightweight Directory Access Protocol，轻量目录访问协议。&lt;/li&gt;
&lt;li&gt;LDAP服务是一个为只读（查询、浏览、搜索）访问而优化的非关系型数据库，呈树状结构组织数据。&lt;/li&gt;
&lt;li&gt;LDAP主要用做用户信息查询（如邮箱、电话等）或对各种服务访问做后台认证以及用户数据权限管控。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;DC：domain component一般为公司名，例如：dc=163,dc=com&lt;/li&gt;
&lt;li&gt;OU：organization unit为组织单元，最多可以有四级，每级最长32个字符，可以为中文&lt;/li&gt;
&lt;li&gt;CN：common name为用户名或者服务器名，最长可以到80个字符，可以为中文&lt;/li&gt;
&lt;li&gt;DN：distinguished name为一条LDAP记录项的名字，有唯一性，例如：dc:”cn=admin,ou=developer,dc=163,dc=com”&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;图形示例&quot;&gt;&lt;a href=&quot;#图形示例&quot; class=&quot;headerlink&quot; title=&quot;图形示例&quot;&gt;&lt;/a&gt;图形示例&lt;/h4&gt;&lt;p&gt;上边来了一堆的名词解释，看的云里雾里，还不是很明白，怎么跟自己的组织架构对应起来呢？看看下边的图是不是清晰明了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/articles/543cefa7/1.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="应用运维" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/"/>
    
      <category term="服务搭建" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Ldap" scheme="http://wandouduoduo.github.io/tags/Ldap/"/>
    
  </entry>
  
  <entry>
    <title>Docker中安装Wiki软件Confluence</title>
    <link href="http://wandouduoduo.github.io/articles/ac0d3377.html"/>
    <id>http://wandouduoduo.github.io/articles/ac0d3377.html</id>
    <published>2019-07-25T07:07:14.000Z</published>
    <updated>2019-08-07T02:06:43.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>本文通过在centos 7上Docker安装Wiki软件Confluence，并通过破解，让公司有一个稳定高效的文档平台。</p><a id="more"></a><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><h4 id="yum安装docker"><a href="#yum安装docker" class="headerlink" title="yum安装docker"></a>yum安装docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`yum update ``# 更新yum``yum ``install` `docker ``# yum安装docker`</span><br></pre></td></tr></table></figure><h4 id="开启镜像加速"><a href="#开启镜像加速" class="headerlink" title="开启镜像加速"></a>开启镜像加速</h4><p>由于国内网络问题拉取 Docker 镜像会十分缓慢，所以可以添加网易镜像地址：<a href="http://hub-mirror.c.163.com" target="_blank" rel="noopener">http://hub-mirror.c.163.com</a> 加速。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`vi` `/etc/docker/daemon``.json`</span><br></pre></td></tr></table></figure><p>将其中的内容替换为如下，当然你可以添加其它镜像地址。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&#123;``  ``"registry-mirrors"``: [``"http://hub-mirror.c.163.com"``]``&#125;`</span><br></pre></td></tr></table></figure><h4 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker --version ``# 查看docker版本``service docker start ``# 启动docker``ps` `-ef | ``grep` `docker ``# 查看docker进程是否正常启动`</span><br></pre></td></tr></table></figure><h2 id="安装数据库PostgreSQL"><a href="#安装数据库PostgreSQL" class="headerlink" title="安装数据库PostgreSQL"></a>安装数据库PostgreSQL</h2><p>安装 PostgreSQL 所使用的镜像在：<a href="https://hub.docker.com/_/postgres/" target="_blank" rel="noopener">https://hub.docker.com/_/postgres/</a></p><h4 id="安装PostgreSQL"><a href="#安装PostgreSQL" class="headerlink" title="安装PostgreSQL"></a>安装PostgreSQL</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker run --name postgresdb -p 5432:5432 -e POSTGRES_PASSWORD=W**** -d postgres`</span><br></pre></td></tr></table></figure><p>注：</p><ol><li>-p 5432:5432 选项是可选的，因为在后面启动Confluence容器的时候，postgresdb这个容器会以别名db连接到confluence容器，也就是说对confluence这个容器来说，可以通过db:5432的网络地址访问到postgresql服务，不需要在主机上开放5432端口。</li><li>W**** 是密码需要设置成你需要的密码</li></ol><h4 id="进入docker容器并创建confluence数据库"><a href="#进入docker容器并创建confluence数据库" class="headerlink" title="进入docker容器并创建confluence数据库"></a>进入docker容器并创建confluence数据库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker ``exec` `-it postgresdb ``bash` `# 进入docker容器``psql -U postgres ``\l``CREATE DATABASE confluence WITH OWNER postgres; ``\q`</span><br></pre></td></tr></table></figure><h2 id="安装wiki-Confluence"><a href="#安装wiki-Confluence" class="headerlink" title="安装wiki Confluence"></a>安装wiki Confluence</h2><p>下文中使用的镜像 <a href="https://hub.docker.com/r/cptactionhank/atlassian-confluence/" target="_blank" rel="noopener">https://hub.docker.com/r/cptactionhank/atlassian-confluence/ </a></p><p>也可以使用 <a href="https://github.com/jgrodziski/docker-confluence/blob/master/Dockerfile" target="_blank" rel="noopener">https://github.com/jgrodziski/docker-confluence/blob/master/Dockerfile</a> 这个镜像他把PostgreSQL和 Confluence包含在一个image里面，参考：<a href="http://blogs.atlassian.com/2013/11/docker-all-the-things-at-atlassian-automation-and-wiring/" target="_blank" rel="noopener">http://blogs.atlassian.com/2013/11/docker-all-the-things-at-atlassian-automation-and-wiring/</a></p><h4 id="安装wiki-Confluence-1"><a href="#安装wiki-Confluence-1" class="headerlink" title="安装wiki Confluence"></a>安装wiki Confluence</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker run -d --name confluence -p 8090:8090 --link postgresdb:db --user root:root cptactionhank``/atlassian-confluence``:latest`</span><br></pre></td></tr></table></figure><p>以上命令将在主机上开放8090端口，如果想使用80端口访问wiki请使用一下命令安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker run -d --name confluence -p 80:8090 --link postgresdb:db --user root:root cptactionhank``/atlassian-confluence``:latest`</span><br></pre></td></tr></table></figure><h4 id="检查confluence是否启动"><a href="#检查confluence是否启动" class="headerlink" title="检查confluence是否启动"></a>检查confluence是否启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker ``ps` `# 列出运行的容器`</span><br></pre></td></tr></table></figure><p>可以看到刚才安装的两个容器，启动 wiki confluence</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker start postgresdb ``# 启动数据库 postgresdb``docker start confluence ``# 启动 Wiki confluence``docker ``ps` `# 列出运行的容器`</span><br></pre></td></tr></table></figure><p>可以看到 wiki confluence已经启动</p><h4 id="浏览器访问"><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h4><p><a href="http://ip/就可以看到Confluence的配置页面" target="_blank" rel="noopener">http://ip/就可以看到Confluence的配置页面</a></p><h2 id="破解Confluence"><a href="#破解Confluence" class="headerlink" title="破解Confluence"></a>破解Confluence</h2><h4 id="访问页面记录Server-ID"><a href="#访问页面记录Server-ID" class="headerlink" title="访问页面记录Server ID"></a>访问页面记录Server ID</h4><p><img src="/articles/ac0d3377/1.png" alt></p><p><img src="/articles/ac0d3377/2.png" alt></p><h4 id="停止-confluence"><a href="#停止-confluence" class="headerlink" title="停止 confluence"></a>停止 confluence</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop confluence #停止 confluence 容器</span><br></pre></td></tr></table></figure><h4 id="进入confluence-容器-查找decoder-jar文件"><a href="#进入confluence-容器-查找decoder-jar文件" class="headerlink" title="进入confluence 容器, 查找decoder.jar文件"></a>进入confluence 容器, 查找decoder.jar文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it confluence /bin/bash # 进入docker容器 confluence</span><br><span class="line">su - # 切换到root账户</span><br><span class="line">find -name "*decoder*" # 查找名称中包括 decoder 的文件</span><br></pre></td></tr></table></figure><p><img src="/articles/ac0d3377/3.png" alt></p><p>将decoder.jar文件从容器中复制出来，其中 “confluence:” 是Wiki confluence容器名称，atlassian-extras-decoder-v2-3.3.0.jar 是安装版本wiki的decode文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker ``cp`  `confluence:``/opt/atlassian/confluence/confluence/WEB-INF/lib/atlassian-extras-decoder-v2-3``.3.0.jar .`</span><br></pre></td></tr></table></figure><h4 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h4><ol><li><ol><li><p>下载 atlassian-extras-decoder-v2-3.3.0.jar 文件到windows上</p></li><li><p>将文件名改为 “atlassian-extras-2.4.jar” 破解工具只识别这个文件名</p></li><li><p>下载破解文件 <a href="http://wiki.wuyijun.cn/download/attachments/2327034/51CTO下载-Confluence.zip" target="_blank" rel="noopener">http://wiki.wuyijun.cn/download/attachments/2327034/51CTO%E4%B8%8B%E8%BD%BD-Confluence.zip</a></p></li><li><p>解压缩此文件夹，dos命令行进入此文件夹，目录需根据你的实际情况修改 C:\Users\lrs\Desktop\wiki\51CTO下载-Confluence\confluence5.1-crack\confluence5.1-crack\iNViSiBLE</p></li><li><p>执行 java -jar confluence_keygen.jar 运行破解文件</p></li><li><p>填入 name ，server id 处输入步骤1中得到的id，点击 “gen” 生成key</p><p><img src="/articles/ac0d3377/4.png" alt></p></li><li><p>点击 patch，选择刚才改名为  “atlassian-extras-2.4.jar” 的jar包，显示 “jar success fully patched” 则破解成功</p><p>注意：path前先删除atlassian-extras-2.4.bak文件否则path失败</p><p><img src="/articles/ac0d3377/5.png" alt></p></li><li><p>将 “atlassian-extras-2.4.jar” 文件名改回原来的 “atlassian-extras-decoder-v2-3.3.0.jar”</p></li><li><p>复制key中的内容备用</p></li><li><p>将 “atlassian-extras-decoder-v2-3.3.0.jar” 文件上传回服务器</p></li></ol></li></ol><h4 id="将破解后的文件复制回-confluence-容器"><a href="#将破解后的文件复制回-confluence-容器" class="headerlink" title="将破解后的文件复制回 confluence 容器"></a>将破解后的文件复制回 confluence 容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker ``cp` `atlassian-extras-decoder-v2-3.3.0.jar  confluence:``/opt/atlassian/confluence/confluence/WEB-INF/lib/atlassian-extras-decoder-v2-3``.3.0.jar`</span><br></pre></td></tr></table></figure><h4 id="启动-confluence-容器"><a href="#启动-confluence-容器" class="headerlink" title="启动 confluence 容器"></a>启动 confluence 容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start confluence</span><br></pre></td></tr></table></figure><h4 id="再次访问页面"><a href="#再次访问页面" class="headerlink" title="再次访问页面"></a>再次访问页面</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip</span><br></pre></td></tr></table></figure><h2 id="平台配置"><a href="#平台配置" class="headerlink" title="平台配置"></a>平台配置</h2><h4 id="输入之前复制的key后点击下一步"><a href="#输入之前复制的key后点击下一步" class="headerlink" title="输入之前复制的key后点击下一步"></a>输入之前复制的key后点击下一步</h4><p><img src="/articles/ac0d3377/6.png" alt></p><h4 id="点击-”My-own-database“-后点击-next"><a href="#点击-”My-own-database“-后点击-next" class="headerlink" title="点击 ”My own database“ 后点击 next"></a>点击 ”My own database“ 后点击 next</h4><p><img src="/articles/ac0d3377/Sun/blog/sunhexo/source/_posts/Docker%E4%B8%AD%E5%AE%89%E8%A3%85Wiki%E8%BD%AF%E4%BB%B6Confluence/7.png" alt></p><h4 id="输入数据库连接信息，用户名密码是之前创建数据库中的用户名和密码"><a href="#输入数据库连接信息，用户名密码是之前创建数据库中的用户名和密码" class="headerlink" title="输入数据库连接信息，用户名密码是之前创建数据库中的用户名和密码"></a>输入数据库连接信息，用户名密码是之前创建数据库中的用户名和密码</h4><p>注意：用户名为 postgres没有db</p><p><img src="/articles/ac0d3377/8.png" alt></p><h4 id="单击-”Empty-Site“"><a href="#单击-”Empty-Site“" class="headerlink" title="单击 ”Empty Site“"></a>单击 ”Empty Site“</h4><p><img src="/articles/ac0d3377/9.png" alt></p><h4 id="点击-“Manage-users-and-groups-within-Confluence”"><a href="#点击-“Manage-users-and-groups-within-Confluence”" class="headerlink" title="点击 “Manage users and groups within Confluence”"></a>点击 “Manage users and groups within Confluence”</h4><p><img src="/articles/ac0d3377/10.png" alt></p><h4 id="填入管理员信息后点击-“next”"><a href="#填入管理员信息后点击-“next”" class="headerlink" title="填入管理员信息后点击 “next”"></a>填入管理员信息后点击 “next”</h4><p><img src="/articles/ac0d3377/11.png" alt></p><h4 id="点击-”start“"><a href="#点击-”start“" class="headerlink" title="点击 ”start“"></a>点击 ”start“</h4><p><img src="/articles/ac0d3377/12.png" alt></p><h4 id="设置一些信息后就完成了"><a href="#设置一些信息后就完成了" class="headerlink" title="设置一些信息后就完成了"></a>设置一些信息后就完成了</h4><p><img src="/articles/ac0d3377/13.png" alt></p><h4 id="查看授权信息，使用管理员用户登录"><a href="#查看授权信息，使用管理员用户登录" class="headerlink" title="查看授权信息，使用管理员用户登录"></a>查看授权信息，使用管理员用户登录</h4><p><img src="/articles/ac0d3377/14.png" alt></p><h4 id="可以看到是评估版本，但过期时间是3千多个月后"><a href="#可以看到是评估版本，但过期时间是3千多个月后" class="headerlink" title="可以看到是评估版本，但过期时间是3千多个月后"></a>可以看到是评估版本，但过期时间是3千多个月后</h4><p><img src="/articles/ac0d3377/15.png" alt></p><h2 id="解决慢时长gc的问题"><a href="#解决慢时长gc的问题" class="headerlink" title="解决慢时长gc的问题"></a>解决慢时长gc的问题</h2><p>默认java配置为1G内存使用一段时间后回经常gc造成卡顿，单击“系统信息”可以看到jvm使用情况</p><p><img src="/articles/ac0d3377/16.png" alt></p><p>进入docker容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it confluence /bin/bash # 进入docker容器 confluence</span><br></pre></td></tr></table></figure><p>修改java配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`vi` `/opt/atlassian/confluence/bin/catalina``.sh`</span><br></pre></td></tr></table></figure><p>在 “cygwin=false” 上面添加如下内容，最大内存为2G</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`JAVA_OPTS=``"-Xms256m -Xmx2048m -XX:PermSize=128m -XX:MaxPermSize=512m"``或``CATALINA_OPTS=``"-Xms256m -Xmx2048m -XX:PermSize=128m -XX:MaxPermSize=512m"`</span><br></pre></td></tr></table></figure><p>重启 wiki confluence</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker stop confluence ``# 停止``docker start confluence ``# 启动`</span><br></pre></td></tr></table></figure><p>这时候可以看到内存为 2G 可用为 73%</p><p><img src="/articles/ac0d3377/17.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;本文通过在centos 7上Docker安装Wiki软件Confluence，并通过破解，让公司有一个稳定高效的文档平台。&lt;/p&gt;
    
    </summary>
    
      <category term="应用监控" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/"/>
    
      <category term="服务搭建" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Docker" scheme="http://wandouduoduo.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>使用Prometheus+Grafana监控JVM</title>
    <link href="http://wandouduoduo.github.io/articles/fd3e6049.html"/>
    <id>http://wandouduoduo.github.io/articles/fd3e6049.html</id>
    <published>2019-07-24T09:56:09.000Z</published>
    <updated>2019-08-07T02:06:43.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>工具：</p><ul><li>Docker，本文大量使用了Docker来启动各个应用。</li><li><a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a>，负责抓取/存储指标信息，并提供查询功能。</li><li><a href="https://grafana.com/" target="_blank" rel="noopener">Grafana</a>，负责数据可视化。</li><li><a href="https://github.com/prometheus/jmx_exporter" target="_blank" rel="noopener">JMX exporter</a>，提供JMX中和JVM相关的metrics。</li><li>Tomcat，用来模拟一个Java应用。</li></ul><p>步骤：</p><ol><li>利用<a href="https://github.com/prometheus/jmx_exporter" target="_blank" rel="noopener">JMX exporter</a>，在Java进程内启动一个小型的Http server</li><li>配置<a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a>抓取那个Http server提供的metrics。</li><li>配置<a href="https://grafana.com/" target="_blank" rel="noopener">Grafana</a>连接<a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a>，配置Dashboard。</li></ol><a id="more"></a><h2 id="启动Java测试实例"><a href="#启动Java测试实例" class="headerlink" title="启动Java测试实例"></a>启动Java测试实例</h2><p>1) 新建一个目录，名字叫做<code>prom-jvm-demo</code>。</p><p>2) <a href="https://repo1.maven.org/maven2/io/prometheus/jmx/jmx_prometheus_javaagent/0.3.1/jmx_prometheus_javaagent-0.3.1.jar" target="_blank" rel="noopener">下载JMX exporter</a>到这个目录</p><p>3) 新建一个文件<code>simple-config.yml</code>内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">lowercaseOutputLabelNames:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">lowercaseOutputName:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">whitelistObjectNames:</span> <span class="string">["java.lang:type=OperatingSystem"]</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="attr"> - pattern:</span> <span class="string">'java.lang&lt;type=OperatingSystem&gt;&lt;&gt;((?!process_cpu_time)\w+):'</span></span><br><span class="line"><span class="attr">   name:</span> <span class="string">os_$1</span></span><br><span class="line"><span class="attr">   type:</span> <span class="string">GAUGE</span></span><br><span class="line"><span class="attr">   attrNameSnakeCase:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>4) 运行以下命令启动3个Tomcat，记得把<code>&lt;path-to-prom-jvm-demo&gt;</code>替换成正确的路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name tomcat-1 \</span><br><span class="line">  -v &lt;path-to-prom-jvm-demo&gt;:/jmx-exporter \</span><br><span class="line">  -e CATALINA_OPTS="-Xms64m -Xmx128m -javaagent:/jmx-exporter/jmx_prometheus_javaagent-0.3.1.jar=6060:/jmx-exporter/simple-config.yml" \</span><br><span class="line">  -p 6060:6060 \</span><br><span class="line">  -p 8080:8080 \</span><br><span class="line">  tomcat:8.5-alpine</span><br><span class="line"></span><br><span class="line">docker run -d \</span><br><span class="line">  --name tomcat-2 \</span><br><span class="line">  -v &lt;path-to-prom-jvm-demo&gt;:/jmx-exporter \</span><br><span class="line">  -e CATALINA_OPTS="-Xms64m -Xmx128m -javaagent:/jmx-exporter/jmx_prometheus_javaagent-0.3.1.jar=6060:/jmx-exporter/simple-config.yml" \</span><br><span class="line">  -p 6061:6060 \</span><br><span class="line">  -p 8081:8080 \</span><br><span class="line">  tomcat:8.5-alpine</span><br><span class="line"></span><br><span class="line">docker run -d \</span><br><span class="line">  --name tomcat-3 \</span><br><span class="line">  -v &lt;path-to-prom-jvm-demo&gt;:/jmx-exporter \</span><br><span class="line">  -e CATALINA_OPTS="-Xms64m -Xmx128m -javaagent:/jmx-exporter/jmx_prometheus_javaagent-0.3.1.jar=6060:/jmx-exporter/simple-config.yml" \</span><br><span class="line">  -p 6062:6060 \</span><br><span class="line">  -p 8082:8080 \</span><br><span class="line">  tomcat:8.5-alpine</span><br></pre></td></tr></table></figure><p>5) 访问<code>http://localhost:8080|8081|8082</code>看看Tomcat是否启动成功。</p><p>6) 访问对应的<code>http://localhost:6060|6061|6062</code>看看JMX exporter提供的metrics。</p><p>备注：这里提供的<code>simple-config.yml</code>仅仅提供了JVM的信息，更复杂的配置请参考<a href="https://github.com/prometheus/jmx_exporter" target="_blank" rel="noopener">JMX exporter文档</a>。</p><h2 id="启动Prometheus"><a href="#启动Prometheus" class="headerlink" title="启动Prometheus"></a>启动Prometheus</h2><p>1) 在之前新建目录<code>prom-jvm-demo</code>，新建一个文件<code>prom-jmx.yml</code>，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'java'</span></span><br><span class="line"><span class="attr">    scrape_interval:</span> <span class="number">30</span><span class="string">s</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">    - targets:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">'&lt;host-ip&gt;:6060'</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">'&lt;host-ip&gt;:6061'</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">'&lt;host-ip&gt;:6062'</span></span><br></pre></td></tr></table></figure><p>2) 启动Prometheus：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name=prometheus \</span><br><span class="line">  -p 9090:9090 \</span><br><span class="line">  -v &lt;path-to-prom-jvm-demo&gt;:/prometheus-config \</span><br><span class="line">  prom/prometheus --config.file=/prometheus-config/prom-jmx.yml</span><br></pre></td></tr></table></figure><p>3) 访问<a href="http://localhost:9090/" target="_blank" rel="noopener">http://localhost:9090</a>看看Prometheus是否启动成功，在输入框里输入<code>jvm_info</code>然后执行，应该可以看到如下图的结果：</p><p><img src="/articles/fd3e6049/1.png" alt></p><p>如果没有看到三个instance，那么等一会儿再试。</p><h2 id="启动Grafana"><a href="#启动Grafana" class="headerlink" title="启动Grafana"></a>启动Grafana</h2><p>1) 启动Grafana：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=grafana -p 3000:3000 grafana/grafana</span><br></pre></td></tr></table></figure><p>2) 访问<a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000</a>，使用<code>admin/admin</code>登录。</p><p>3) 添加Prometheus数据源，如下图所示到添加数据源页面：</p><p><img src="/articles/fd3e6049/2.png" alt></p><p>4) 配置数据源信息：</p><ul><li>Name：随便取</li><li>Type：Prometheus</li><li>URL：<code>http://&lt;host-ip&gt;:9090</code></li><li>其余不要设置，点击<code>Save &amp; Test</code>，应该会返回成功结果</li></ul><p>5) 导入Dashboard。我们不需要重头自己做Dashboard，用现成的就行，按下图所示进入导入页面</p><p><img src="/articles/fd3e6049/3.png" alt></p><p>6) 使用我制作的<a href="https://grafana.com/dashboards/8563" target="_blank" rel="noopener">JVM Dashboard</a>，页面右侧出现的ID号是<code>8563</code>，记住这个号，填在如下图所示的位置：</p><p><img src="/articles/fd3e6049/4.png" alt></p><p>7) 然后鼠标点击别处稍等一下，出现下图，选择一下数据源就可以了</p><p><img src="/articles/fd3e6049/5.png" alt></p><p>8) 最后打开刚刚导入的Dashboard，如下图：</p><p><img src="/articles/fd3e6049/6.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker，本文大量使用了Docker来启动各个应用。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://prometheus.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Prometheus&lt;/a&gt;，负责抓取/存储指标信息，并提供查询功能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://grafana.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Grafana&lt;/a&gt;，负责数据可视化。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/prometheus/jmx_exporter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JMX exporter&lt;/a&gt;，提供JMX中和JVM相关的metrics。&lt;/li&gt;
&lt;li&gt;Tomcat，用来模拟一个Java应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用&lt;a href=&quot;https://github.com/prometheus/jmx_exporter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JMX exporter&lt;/a&gt;，在Java进程内启动一个小型的Http server&lt;/li&gt;
&lt;li&gt;配置&lt;a href=&quot;https://prometheus.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Prometheus&lt;/a&gt;抓取那个Http server提供的metrics。&lt;/li&gt;
&lt;li&gt;配置&lt;a href=&quot;https://grafana.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Grafana&lt;/a&gt;连接&lt;a href=&quot;https://prometheus.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Prometheus&lt;/a&gt;，配置Dashboard。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="应用运维" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/"/>
    
      <category term="监控积累" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/%E7%9B%91%E6%8E%A7%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="Prometheus" scheme="http://wandouduoduo.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>gitlab安装配置手册(Docker版)</title>
    <link href="http://wandouduoduo.github.io/articles/87b11c95.html"/>
    <id>http://wandouduoduo.github.io/articles/87b11c95.html</id>
    <published>2019-07-24T06:32:39.000Z</published>
    <updated>2019-08-07T02:06:43.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>使用Docker容器来快速安装配置和使用的gitlab</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hub.docker.com/r/twang2218/gitlab-ce-zh/" target="_blank" rel="noopener">gitlab官网镜像</a></p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 构建外挂目录</span></span><br><span class="line">mkdir -p /etc/gitlab /var/log/gitlab /var/opt/gitlab</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取镜像并运行实例</span></span><br><span class="line">docker run -d \</span><br><span class="line">    -p 9999:80 \ # 指定web访问端口</span><br><span class="line">    --cpu-shares 2048 \ # 限制CPU资源，最少2core，参考：https://docs.gitlab.com.cn/ce/install/requirements.html</span><br><span class="line">    --cpu-period=20000 \</span><br><span class="line">    --cpu-quota=20000 \</span><br><span class="line">    --memory 4294967296 \ # 限制内存，最少4G</span><br><span class="line">    --hostname xxxx.com \ # 绑定git clone的访问域名，与ngx上一致</span><br><span class="line">    --name gitlab \</span><br><span class="line">    --privileged=true \ # 忽略挂载目录的权限</span><br><span class="line">    -v /etc/gitlab:/etc/gitlab \ # 外挂相关路径</span><br><span class="line">    -v /var/log/gitlab:/var/log/gitlab \</span><br><span class="line">    -v /var/opt/gitlab:/var/opt/gitlab \</span><br><span class="line">    twang2218/gitlab-ce-zh:10.2</span><br></pre></td></tr></table></figure><h2 id="配置优化"><a href="#配置优化" class="headerlink" title="配置优化"></a>配置优化</h2><h4 id="限制worker进程数"><a href="#限制worker进程数" class="headerlink" title="限制worker进程数"></a><strong>限制worker进程数</strong></h4><p>默认配置中，worker进程数与本机CPU个数一致，会大量占用内存，导致容器的内存持续增长，直至服务宕机，报5xx</p><p>解决方案：修改/etc/gitlab/gitlab.rb中配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################################################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># GitLab Unicorn</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#! Tweak unicorn settings.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#! Docs: https://docs.gitlab.com/omnibus/settings/unicorn.html</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################################################################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> unicorn[<span class="string">'worker_timeout'</span>] = 60</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##! Minimum worker_processes is 2 at this moment</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##! See https://gitlab.com/gitlab-org/gitlab-ce/issues/18771</span></span></span><br><span class="line">unicorn['worker_processes'] = 2 # 去除原注释，指定worker数和分配的CPU个数一致</span><br></pre></td></tr></table></figure><p><strong>然后重启</strong></p><h4 id="启用邮件通知"><a href="#启用邮件通知" class="headerlink" title="启用邮件通知"></a>启用邮件通知</h4><p>编辑/etc/gitlab/gitlab.rb</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">……之前配置略……</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## Email Settings</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gitlab_rails[<span class="string">'gitlab_email_enabled'</span>] = <span class="literal">true</span></span></span><br><span class="line">gitlab_rails['gitlab_email_from'] = 'xxxxx'</span><br><span class="line"><span class="meta">#</span><span class="bash"> gitlab_rails[<span class="string">'gitlab_email_display_name'</span>] = <span class="string">'xxxxx'</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gitlab_rails[<span class="string">'gitlab_email_reply_to'</span>] = <span class="string">'noreply@example.com'</span></span></span><br><span class="line">gitlab_rails['gitlab_email_subject_suffix'] = '[xxx.gitlab]'</span><br><span class="line">……</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## GitLab email server settings</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##! Docs: https://docs.gitlab.com/omnibus/settings/smtp.html</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##! **Use smtp instead of sendmail/postfix.**</span></span></span><br><span class="line">gitlab_rails['smtp_enable'] = true</span><br><span class="line">gitlab_rails['smtp_address'] = "xxxx"</span><br><span class="line">gitlab_rails['smtp_port'] = 25</span><br><span class="line">gitlab_rails['smtp_user_name'] = "xxxxx"</span><br><span class="line">gitlab_rails['smtp_password'] = "xxxxx"</span><br><span class="line"><span class="meta">#</span><span class="bash"> gitlab_rails[<span class="string">'smtp_domain'</span>] = <span class="string">"xxxxx"</span></span></span><br><span class="line">gitlab_rails['smtp_authentication'] = "login"</span><br><span class="line">gitlab_rails['smtp_enable_starttls_auto'] = true</span><br><span class="line"><span class="meta">#</span><span class="bash"> gitlab_rails[<span class="string">'smtp_tls'</span>] = <span class="literal">false</span></span></span><br><span class="line">……</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h4 id="备份操作"><a href="#备份操作" class="headerlink" title="备份操作"></a>备份操作</h4><h6 id="Gitlab的备份目录路径设置"><a href="#Gitlab的备份目录路径设置" class="headerlink" title="Gitlab的备份目录路径设置"></a><strong>Gitlab的备份目录路径设置</strong></h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">gitlab_rails['manage_backup_path'] = true</span><br><span class="line">gitlab_rails['backup_path'] = "/data/gitlab/backups"   //gitlab备份目录</span><br><span class="line">gitlab_rails['backup_archive_permissions'] = 0644      //生成的备份文件权限</span><br><span class="line">gitlab_rails['backup_keep_time'] = 7776000             //备份保留天数为3个月（即90天，这里是7776000秒）</span><br><span class="line"></span><br><span class="line">mkdir -p /data/gitlab/backups</span><br><span class="line">chown -R git.git /data/gitlab/backups</span><br><span class="line">chmod -R 777 /data/gitlab/backups</span><br><span class="line"></span><br><span class="line">gitlab-ctl reconfigure  #重新加载配置</span><br></pre></td></tr></table></figure><h6 id="GItlab备份操作"><a href="#GItlab备份操作" class="headerlink" title="GItlab备份操作"></a><strong>GItlab备份操作</strong></h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 手动备份</span></span><br><span class="line">cd /data/gitlab/backups/</span><br><span class="line">gitlab-rake gitlab:backup:create</span><br><span class="line"><span class="meta">#</span><span class="bash">上面步骤是自动备份，查看备份文件</span></span><br><span class="line">ll </span><br><span class="line">-rw-r--r-- 1 git git 245760 Nov 12 15:33 1510472027_2017_11_12_9.4.5_gitlab_backup.tar</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">自动备份</span></span><br><span class="line">cd /data/gitlab/backups/</span><br><span class="line"><span class="meta">#</span><span class="bash">编写备份脚本</span></span><br><span class="line">vim gitlab_backup.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">/usr/bin/gitlab-rake gitlab:backup:create CRON=1</span><br><span class="line"></span><br><span class="line">注意：环境变量CRON=1的作用是如果没有任何错误发生时， 抑制备份脚本的所有进度输出</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">编写备份脚本，结合crontab实施自动定时备份，比如每天0点、6点、12点、18点各备份一次</span></span><br><span class="line">0 0,6,12,18 * * * /bin/bash -x /data/gitlab/backups/gitlab_backup.sh &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h4 id="恢复操作"><a href="#恢复操作" class="headerlink" title="恢复操作"></a>恢复操作</h4><p>注意：GItlab只能还原到与备份文件相同的gitlab版本。</p><h6 id="停止相关数据连接服务"><a href="#停止相关数据连接服务" class="headerlink" title="停止相关数据连接服务"></a>停止相关数据连接服务</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl stop unicorn</span><br><span class="line">gitlab-ctl stop sidekiq</span><br><span class="line">gitlab-ctl status</span><br></pre></td></tr></table></figure><h6 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入目录</span></span><br><span class="line">cd /data/gitlab/backups</span><br><span class="line"><span class="meta">#</span><span class="bash">查看备份</span></span><br><span class="line">ll</span><br><span class="line">-rw-r--r-- 1 git git 245760 Nov 12 15:33 1510472027_2017_11_12_9.4.5_gitlab_backup.tar</span><br><span class="line"><span class="meta">#</span><span class="bash">Gitlab的恢复操作会先将当前所有的数据清空，然后再根据备份数据进行恢复</span></span><br><span class="line">gitlab-rake gitlab:backup:restore BACKUP=1510472027_2017_11_12_9.4.5</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">gitlab-ctl start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证检查</span></span><br><span class="line">gitlab-rake gitlab:check SANITIZE=true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;使用Docker容器来快速安装配置和使用的gitlab&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/r/twang2218/gitlab-ce-zh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gitlab官网镜像&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="应用运维" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/"/>
    
      <category term="服务搭建" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Git" scheme="http://wandouduoduo.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构系列思考&lt;三&gt;</title>
    <link href="http://wandouduoduo.github.io/articles/32a029fb.html"/>
    <id>http://wandouduoduo.github.io/articles/32a029fb.html</id>
    <published>2019-07-17T14:03:49.000Z</published>
    <updated>2019-08-07T02:06:43.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题起源"><a href="#问题起源" class="headerlink" title="问题起源"></a>问题起源</h2><p>Spring Cloud微服务架构体系中，Eureka是一个至关重要的组件，它扮演着微服务注册中心的角色，所有的服务注册与服务发现，都是依赖Eureka的。</p><p>之前不少初学Spring Cloud的朋友在落地公司的生产环境部署时，经常会有一个疑问：Eureka Server到底要部署几台机器？</p><p>我们的系统那么多服务，到底会对Eureka Server产生多大的访问压力？Eureka Server能不能抗住一个大型系统的访问压力？</p><p>你现在心里一定很多疑问，别着急，咱们这就去探索一下，Eureka作为微服务注册中心的核心原理。下面这些问题，大伙儿先看看，有个大概的印象。</p><p>带着这些问题，来看后面的内容，效果更佳。</p><p>● Eureka注册中心使用什么样的方式来储存各个服务注册时发送过来的机器地址和端口号？</p><p>● 各个服务找Eureka Server拉取注册表的时候，是什么样的频率？</p><p>● 各个服务是如何拉取注册表的？</p><p>● 对于一个有几百个服务，部署上千台机器的大型分布式系统来说，这套系统会对Eureka Server造成多大的访问压力？</p><p>● Eureka Server从技术层面是如何抗住日千万级访问量的？</p> <a id="more"></a><p>先给大家说一个基本知识点，各个服务内的Eureka Client组件，默认情况下，每隔30秒会发送一个请求到Eureka Server，来拉取最近有变化的服务信息</p><p>举个例子：</p><p>● 库存服务原本部署在1台机器上，现在扩容了，部署到了3台机器，并且均注册到了Eureka Server上。</p><p>● 然后订单服务的Eureka Client会每隔30秒去找Eureka Server拉取最近注册表的变化，看看其他服务的地址有没有变化。</p><p>除此之外，对Eureka Server一个比较常见的请求就是心跳，各个Eureka Client都会每隔30秒发送一次心跳请求到Eureka Server，通知人家说，哥们，我这个服务实例还活着！</p><p>如果某个Eureka Client很长时间没有发送心跳给Eureka Server，那么就说明这个服务实例已经挂了。</p><p>光看上面的文字，各位童鞋可能没什么印象。老规矩！咱们还是来一张图，一起来直观的感受一下这个过程。</p><p>过程如图所示：</p><p><img src="/articles/32a029fb/1.jpg" alt></p><h2 id="Eureka-Server设计精妙的注册表存储结构"><a href="#Eureka-Server设计精妙的注册表存储结构" class="headerlink" title="Eureka Server设计精妙的注册表存储结构"></a>Eureka Server设计精妙的注册表存储结构</h2><p>现在咱们假设你手头有一套大型的分布式系统，这套系统一共有100个服务，每个服务部署在20台机器上，机器是4核8G的标准配置。</p><p>这相当于什么呢？也就是说相当于你一共部署了100 * 20 = 2000个服务实例，有2000台机器。</p><p>而每台机器上的服务实例内部都有一个Eureka Client组件，这个Eureka Client组件每隔30秒会请求一次Eureka Server来拉取变化的注册表。</p><p>此外，每个服务实例上的Eureka Client都会每隔30秒发送一次心跳请求给Eureka Server。</p><p>那么大家算算，Eureka Server作为一个微服务注册中心，每秒钟要被请求多少次？一天要被请求多少次？</p><p>● 很简单，我们就按最标准的算法来算，即每个服务实例每分钟请求2次拉取注册表，每分钟请求2次发送心跳</p><p>● 这样的话，一个服务实例每分钟会请求4次，2000个服务实例每分钟请求8000次</p><p>● 换算到每秒钟，则是8000 / 60 = 133次左右，我们直接可以大概估算为Eureka Server每秒钟会被请求150次</p><p>● 所以，一天的话，应该就是8000 * 60 * 24 = 1152万，也就是每天千万级访问量</p><p> 好！经过这么一个测算，大家是否发现这里的奥秘了？</p><p>● 首先第一点，对于微服务注册中心这种组件，在一开始设计他这个注册表的拉取频率以及心跳发送频率的时候，就已经考虑到了一个大型系统的各个服务请求时的压力，每秒会承载多大的请求量。</p><p>● 所以说各个服务实例每隔30秒发起一次请求拉取变化的注册表，以及每隔30秒发送一次心跳给Eureka Server，其实这个时间安排是有他的用意的。</p><p>按照我们的测算，一个上百个服务，部署几千台机器的大规模系统，按照这样的一个频率请求Eureka Server，日请求量在千万级，每秒的访问量应该是固定在150次左右，即使算上其他的一些额外操作，算到每秒钟请求Eureka Server在200次~300次吧。</p><p>所以通过设置一个适中的拉取注册表以及发送心跳的频率，保证大规模系统里对Eureka Server的请求压力不会太大。</p><p>关键问题来了，Eureka Server是如何保证轻松抗住这每秒数百次请求，每天千万级请求的呢？</p><p>要搞清楚这个，首先得清楚人家Eureka Server到底是用什么来存储注册表的？三个字，看源码！</p><p>接下来咱们就一起进入Eureka的源码里一探究竟：</p><p> <img src="/articles/32a029fb/2.png" alt></p><p>● 如上图所示，图中名为registry的CocurrentHashMap，就是注册表的核心结构。看完之后忍不住先赞叹一下，真是精妙的设计！</p><p>● 从代码中可以看到，Eureka Server的注册表直接基于纯内存，就是在内存里维护了一个数据结构。</p><p>● 各个服务发起注册、服务下线、服务故障，全部会在内存里维护和更新这个注册表。</p><p>● 各个服务每隔30秒拉取注册表的时候，其实Eureka Server就是直接提供内存里存储的有变化的注册表数据给他们就可以了。</p><p>● 同样，每隔30秒发起心跳的时候，也是在这个纯内存的CocurrentHashMap数据结构里更新心跳时间。</p><p>一句话概括：维护注册表、拉取注册表、更新心跳时间，全部发生在内存里！这就是Eureka Server非常核心的一个点。</p><p>搞清楚了这一点，咱们再来分析一下这个叫做registry的东西的数据结构，大家千万别被它复杂的外表唬住了，沉下心来，一层层的分析！</p><p>● 首先，这个ConcurrentHashMap的key就是服务名称，比如说“inventory-service”，就是一个服务名称。</p><p>● 而value：Map&lt;String, Lease<instanceinfo>则代表了一个服务的多个服务实例。</instanceinfo></p><p>● 举个例子：比如说“inventory-service”是可以有3个服务实例的，每个服务实例部署在一台机器上</p><p>接下来咱们再来看里面这个小Map：</p><p>Map&lt;String, Lease<instanceinfo></instanceinfo></p><p>● 这个Map的key就是服务实例的id</p><p>● value是一个叫做 Lease<instanceinfo>的东西。这又是什么鬼呢？</instanceinfo></p><p>■ 首先说下InstanceInfo，其实啊，我们见名知义，这个InstanceInfo就代表了服务实例的具体信息，比如机器的ip地址、hostname以及端口号</p><p>■ 而Lease<instanceinfo>的这个Lease，里面则会维护每个服务最近一次发送心跳的时间</instanceinfo></p><h2 id="Eureka-Server端优秀的多级缓存机制"><a href="#Eureka-Server端优秀的多级缓存机制" class="headerlink" title="Eureka Server端优秀的多级缓存机制"></a>Eureka Server端优秀的多级缓存机制</h2><p>假设Eureka Server部署在4核8G的普通机器上，那么基于内存来承载各个服务的请求，每秒钟最多可以处理多少请求呢？</p><p>● 根据之前做过的测试，单台4核8G的机器，处理一些纯内存的操作，哪怕加上一些网络请求的开销，每秒处理几百请求是很轻松的。哪怕是更大规模的机器和请求量，处理起来，也是轻松加愉快。</p><p>● 而且Eureka Server为了避免同时读写内存数据结构造成的并发冲突问题，还采用了多级缓存机制来进一步提升服务请求的响应速度。</p><p>● 在拉取注册表的时候：</p><p>◑ 首先从ReadOnlyCacheMap里查缓存的注册表。</p><p>◑ 如果没有，就找ReadWriteCacheMap里缓存的注册表。</p><p>◑ 如果还没有，就从内存中获取实际的注册表数据。</p><p>● 在注册表发生变更的时候：</p><p>◑ 会在内存中更新变更的注册表数据，同时过期掉ReadWriteCacheMap。</p><p>◑ 这个过程不会影响ReadOnlyCacheMap提供人家查询注册表。</p><p>◑ 在一段时间内，默认是30秒，各个服务拉取注册表数据都会直接读ReadOnlyCacheMap。</p><p>◑ 在30秒过后，Eureka Server的后台线程发现ReadWriteCacheMap已经清空了，那么也会清空ReadOnlyCacheMap中的缓存</p><p>◑ 下次有服务拉取注册表，又会从内存中获取最新的数据了，同时填充各个缓存。</p><p>多级缓存机制的优点是什么？</p><p>1.这种多级缓存机制的设计，尽可能保证了内存注册表数据不会出现频繁的读写冲突问题。</p><p>2.并且进一步保证对Eureka Server的大量请求，都是快速从纯内存走，性能极高。</p><p>为方便大家更好的理解，同样来一张图，大家跟着图再来回顾一下这整个过程：</p><p> <img src="/articles/32a029fb/3.jpg" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>● 通过上面的分析可以看到，Eureka通过设置适当的请求频率（拉取注册表30秒间隔，发送心跳30秒间隔），可以保证一个大规模的系统每秒请求Eureka Server的次数在几百次。</p><p>● 同时还通过纯内存的注册表，保证了所有的请求都可以在内存处理，这样确保了极高的性能，普通机器一秒钟处理几百请求都是轻松+愉快的。</p><p>● 另外还有多级缓存机制，确保说不会针对内存数据结构发生频繁的读写并发冲突操作，进一步提升性能。</p><p>上述就是Spring Cloud架构中，Eureka作为微服务注册中心可以承载大规模系统每天千万级访问量的原理</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题起源&quot;&gt;&lt;a href=&quot;#问题起源&quot; class=&quot;headerlink&quot; title=&quot;问题起源&quot;&gt;&lt;/a&gt;问题起源&lt;/h2&gt;&lt;p&gt;Spring Cloud微服务架构体系中，Eureka是一个至关重要的组件，它扮演着微服务注册中心的角色，所有的服务注册与服务发现，都是依赖Eureka的。&lt;/p&gt;
&lt;p&gt;之前不少初学Spring Cloud的朋友在落地公司的生产环境部署时，经常会有一个疑问：Eureka Server到底要部署几台机器？&lt;/p&gt;
&lt;p&gt;我们的系统那么多服务，到底会对Eureka Server产生多大的访问压力？Eureka Server能不能抗住一个大型系统的访问压力？&lt;/p&gt;
&lt;p&gt;你现在心里一定很多疑问，别着急，咱们这就去探索一下，Eureka作为微服务注册中心的核心原理。下面这些问题，大伙儿先看看，有个大概的印象。&lt;/p&gt;
&lt;p&gt;带着这些问题，来看后面的内容，效果更佳。&lt;/p&gt;
&lt;p&gt;● Eureka注册中心使用什么样的方式来储存各个服务注册时发送过来的机器地址和端口号？&lt;/p&gt;
&lt;p&gt;● 各个服务找Eureka Server拉取注册表的时候，是什么样的频率？&lt;/p&gt;
&lt;p&gt;● 各个服务是如何拉取注册表的？&lt;/p&gt;
&lt;p&gt;● 对于一个有几百个服务，部署上千台机器的大型分布式系统来说，这套系统会对Eureka Server造成多大的访问压力？&lt;/p&gt;
&lt;p&gt;● Eureka Server从技术层面是如何抗住日千万级访问量的？&lt;/p&gt;
    
    </summary>
    
      <category term="应用运维" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Java" scheme="http://wandouduoduo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构系列思考&lt;二&gt;</title>
    <link href="http://wandouduoduo.github.io/articles/4c5309d0.html"/>
    <id>http://wandouduoduo.github.io/articles/4c5309d0.html</id>
    <published>2019-07-17T13:43:53.000Z</published>
    <updated>2019-08-07T02:06:43.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>相信不少朋友都在自己公司使用Spring Cloud框架来构建微服务架构，毕竟现在这是非常火的一门技术。</p><p>如果只是用户量很少的传统IT系统，使用Spring Cloud可能还暴露不出什么问题。</p><p>如果是较多用户量，高峰每秒高达上万并发请求的互联网公司的系统，使用Spring Cloud技术就有一些问题需要注意了。</p><a id="more"></a><h2 id="真实案例"><a href="#真实案例" class="headerlink" title="真实案例"></a>真实案例</h2><h4 id="场景引入，问题初现"><a href="#场景引入，问题初现" class="headerlink" title="场景引入，问题初现"></a>场景引入，问题初现</h4><p>先不空聊原理、理论，来讲一个真实的例子，这是我的一个朋友在创业互联网公司发生过的真实案例。</p><p>朋友A的公司做互联网类的创业，组建了一个小型研发团队，上来就用了Spring Cloud技术栈来构建微服务架构的系统。一段时间没日没夜的加班，好不容易核心业务系统给做出来了，平时正常QA测试没发现什么大毛病，感觉性能还不错，一切都很完美。<br>然后系统就这么上线了，一开始用户规模很小，注册用户量小几十万，日活几千用户。</p><p>每天都有新的数据进入数据库的表中，就这么日积月累的，没想到数据规模居然慢慢吞吞增长到了单表几百万。</p><p>这个时候呢，看起来也没太大的毛病，就是有用户反映，系统有些操作，会感觉卡顿几秒钟，会刷不出来页面。</p><p><strong>这是为啥呢？</strong></p><ul><li>核心原因是单表数据量大了一些，达到了几百万。</li><li>有个别服务，跑的SQL比较复杂，一大堆的多表关联</li><li>并且还没有设计好索引，或者是设计了索引，但无奈一些小弟写了上百行的大SQL，SQL实在太复杂了，那么一个SQL跑出来好几秒肯定是正常的。</li></ul><p>如果大家对微服务框架有点了解的话，应该知道，比如Feign + Ribbon组成的服务调用框架，是有接口调用超时这一说的，有一些参数可以设置接口调用的超时时间。</p><p>如果你调用一个接口，好几秒刷不出来，人家就超时异常返回，用户就刷不出来页面了。</p><h4 id="扬汤止沸，饮鸩止渴"><a href="#扬汤止沸，饮鸩止渴" class="headerlink" title="扬汤止沸，饮鸩止渴"></a>扬汤止沸，饮鸩止渴</h4><p>一般碰到这种事情，一大坨屎一样的SQL摆在那儿，写SQL的人过一个月自己都看不懂了，80%的工程师看着都不愿意去花时间重写和优化。</p><p>一是修改的人力成本太高，二是谁敢负担这责任呢？系统跑的好好的，就是慢了点而已，结果你硬是乱改一通，重构，把系统核心业务流程搞挂了怎么办？</p><p>所以说，那些兄弟第一反应是：增加超时时间啊！接口慢点可以，但是别超时不响应啊！</p><p>让接口执行个几秒把结果返回，用户不就可以刷出来页面了！不用重构系统了啊！轻松+愉快！</p><p>如何增加呢？很简单，看下面的参数就知道了：</p><p> <img src="/articles/4c5309d0/1.jpg" alt> </p><p>大家如果看过之前的文章，应该知道，Spring Cloud里一般会用hystrix的线程池来执行接口调用的请求。。</p><p>所以设置超时一般设置两个地方，feign和ribbon那块的超时，还有hystrix那块的超时。其中后者那块的超时一般必须大于前者。</p><p>Spring Cloud玩儿的好的兄弟，可千万别看着这些配置发笑，因为我确实见过不少Spring Cloud玩儿的没那么溜的哥们，真的就这么干了。</p><p>好了，日子在继续。。。</p><p>优化了参数后，看上去效果不错，用户虽然觉得有的页面慢是慢点，但是起码过几秒能刷出来。</p><p>这个时候，日活几千的用户量，压根儿没什么并发可言，高峰期每秒最多一二十并发请求罢了。</p><p>大家看看下面这张图，感受一下现场氛围：</p><p><img src="/articles/4c5309d0/2.jpg" alt></p><h4 id="问题爆发，洪水猛兽"><a href="#问题爆发，洪水猛兽" class="headerlink" title="问题爆发，洪水猛兽"></a>问题爆发，洪水猛兽</h4><p>随着时间的推移，公司业务高速发展……</p><p>那位兄弟的公司，在系统打磨成熟，几万用户试点都ok之后，老板立马拿到一轮几千万的融资。</p><p>公司上上下下意气风发啊！紧接着就是组建运营团队，地推团队，全国大范围的推广。</p><p>总之就是三个字：推！推！推！</p><p>这一推不打紧！研发人员在后台系统发现，自己的用户量蹭蹭蹭的增长，注册用户增长了几十倍，突破了千万级别，日活用户也翻了几十倍，在活动之类的高峰期，居然达到了上百万的日活用户量。。。</p><p>幸福的烦恼。。。</p><p>为什么这么说？因为用户量上来后，悲剧的事情就发生了。</p><p><strong>高峰期每秒的并发请求居然达到了近万的程度</strong>，研发团队的兄弟们哪里敢怠慢！在这个过程中，先是紧张的各种扩容服务，一台变两台，两台变八台。</p><p>然后数据库主从架构挂上去，读写分离是必须的，否则单个数据库服务器哪能承载那么大的请求！多搞几个从库，扛一下大量的读请求，这样基本就扛住了。</p><p>正准备松口气，更加悲剧的事情就发生了。</p><p>在这个过程中，那些兄弟经常会发现高峰期，系统的某个功能页面，突然就整个hang死了，就是没法再响应任何请求！所有用户刷新这个页面全部都是无法响应！</p><p>这是为什么呢？</p><p><strong>原因很简单啊</strong>！一个服务A的实例里，专门调用服务B的那个线程池里的线程，总共可能就几十个。每个线程调用服务B都会卡住5秒钟。</p><p>那如果每秒钟过来几百个请求这个服务实例呢？一下子那个线程池里的线程就全部hang死了，没法再响应任何请求了。</p><p>大家来看看下面这张图，再直观的感受一下这个无助的过程！</p><p> <img src="/articles/4c5309d0/3.jpg" alt></p><p>这个时候咋办？兄弟们只能祭出程序员最古老的法宝，重启机器！</p><p>遇到页面刷不出来，只能重启机器，相当于短暂的初始化了一下机器内的资源。</p><p>然后接着运行一段时间，又卡死，再次重启！真是令人崩溃啊！用户们的体验是极差的，老板的心情是愤怒的！</p><p>画外音：</p><p>其实这个问题本身不大，但如果对Spring Cloud没有高并发场景的真实经验，确实可能会跟这帮兄弟一样，搞出些莫名其妙的问题。</p><p>比如这个公司，明明应该去优化服务接口性能，结果硬是调大了超时时间。结果导致并发量高了，对那个服务的调用直接hang死，系统的核心页面刷不出来，影响用户体验了，这怪谁呢？</p><h4 id="追本溯源，治标治本"><a href="#追本溯源，治标治本" class="headerlink" title="追本溯源，治标治本"></a>追本溯源，治标治本</h4><p>没法子了，那帮兄弟们只能找人求助。下面就是他们完成系统优化的过程。</p><p><strong>第一步</strong></p><p>关键点，优化图中核心服务B的性能。互联网公司，核心业务逻辑，面向C端用户高并发的请求，不要用上百行的大SQL，多表关联，那样单表几百万行数据量的话，会导致一下执行好几秒。</p><p>其实最佳的方式，就是对数据库就执行简单的单表查询和更新，然后复杂的业务逻辑全部放在java系统中来执行，比如一些关联，或者是计算之类的工作。</p><p>这一步干完了之后，那个核心服务B的响应速度就已经优化成几十毫秒了，是不是很开心？从几秒变成了几十毫秒！</p><p><strong>第二步</strong></p><p>那个超时的时间，也就是上面那段ribbon和hystrix的超时时间设置。</p><p>奉劝各位同学，不要因为系统接口的性能过差而懒惰，搞成几秒甚至几十秒的超时，一般超时定义在1秒以内，是比较通用以及合理的。</p><p>为什么这么说？</p><p>因为一个接口，理论的最佳响应速度应该在200ms以内，或者慢点的接口就几百毫秒。</p><p>如果一个接口响应时间达到1秒+，建议考虑用缓存、索引、NoSQL等各种你能想到的技术手段，优化一下性能。</p><p>否则你要是胡乱设置超时时间是几秒，甚至几十秒，万一下游服务偶然出了点问题响应时间长了点呢？那你这个线程池里的线程立马全部卡死！</p><p>具体hystrix的线程池以及超时时间的最佳生产实践，请见下一篇文章：《微服务架构如何保障双11狂欢下的99.99%高可用》</p><p>这两步解决之后，其实系统表现就正常了，核心服务B响应速度很快速，而且超时时间也在1秒以内，不会出现hystrix线程池频繁卡死的情况了。</p><p><strong>第三步</strong></p><p>事儿还没完，你要真觉得两步就搞定了，那还是经验不足。</p><p>如果你要是超时时间设置成了1秒，如果就是因为偶然发生的网络抖动，导致接口某次调用就是在1.5秒呢？这个是经常发生的，因为网络的问题，接口调用偶然超时。</p><p>所以此时配合着超时时间，一般都会设置一个合理的重试，如下所示：</p><p> <img src="/articles/4c5309d0/4.jpg" alt></p><p>设置这段重试之后，Spring Cloud中的Feign + Ribbon的组合，在进行服务调用的时候，如果发现某台机器超时请求失败，会自动重试这台机器，如果还是不行会换另外一台机器重试。</p><p>这样由于偶尔的网络请求造成的超时，不也可以通过自动重试避免了？</p><p><strong>第四步</strong></p><p>其实事儿还没完，如果把重试参数配置了，结果你居然就放手了，那还是没对人家负责任啊！</p><p>你的系统架构中，只要涉及到了重试，那么必须上接口的幂等性保障机制。</p><p>否则的话，试想一下，你要是对一个接口重试了好几次，结果人家重复插入了多条数据，该怎么办呢？</p><p>其实幂等性保证本身并不复杂，根据业务来，常见的方案：</p><p>可以在数据库里建一个唯一索引，插入数据的时候如果唯一索引冲突了就不会插入重复数据<br>或者是通过redis里放一个唯一id值，然后每次要插入数据，都通过redis判断一下，那个值如果已经存在了，那么就不要插入重复数据了。<br>类似这样的方案还有一些。总之，要保证一个接口被多次调用的时候，不能插入重复的数据。</p><h2 id="总结全文"><a href="#总结全文" class="headerlink" title="总结全文"></a>总结全文</h2><p>有图有真相！老规矩，最后给大家上一张图，最终优化后的系统表现大概是长下面这样子的。</p><p> <img src="/articles/4c5309d0/5.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;相信不少朋友都在自己公司使用Spring Cloud框架来构建微服务架构，毕竟现在这是非常火的一门技术。&lt;/p&gt;
&lt;p&gt;如果只是用户量很少的传统IT系统，使用Spring Cloud可能还暴露不出什么问题。&lt;/p&gt;
&lt;p&gt;如果是较多用户量，高峰每秒高达上万并发请求的互联网公司的系统，使用Spring Cloud技术就有一些问题需要注意了。&lt;/p&gt;
    
    </summary>
    
      <category term="应用运维" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Java" scheme="http://wandouduoduo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构系列思考&lt;一&gt;</title>
    <link href="http://wandouduoduo.github.io/articles/e36292b2.html"/>
    <id>http://wandouduoduo.github.io/articles/e36292b2.html</id>
    <published>2019-07-17T13:08:42.000Z</published>
    <updated>2019-08-07T02:06:43.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>毫无疑问，Spring Cloud是目前微服务架构领域的翘楚，无数的书籍博客都在讲解这个技术。不过大多数讲解还停留在对Spring Cloud功能使用的层面，其底层的很多原理，很多人可能并不知晓。因此本文将通过大量的手绘图，给大家谈谈Spring Cloud微服务架构的底层原理。</p><p>实际上，Spring Cloud是一个全家桶式的技术栈，包含了很多组件。本文先从其最核心的几个组件入手，来剖析一下其底层的工作原理。也就是Eureka、Ribbon、Feign、Hystrix、Zuul这几个组件。</p> <a id="more"></a><h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>先来给大家说一个业务场景，假设咱们现在开发一个电商网站，要实现支付订单的功能，流程如下：</p><p>创建一个订单之后，如果用户立刻支付了这个订单，我们需要将订单状态更新为“已支付”</p><p>扣减相应的商品库存</p><p>通知仓储中心，进行发货</p><p>给用户的这次购物增加相应的积分</p><p>针对上述流程，我们需要有<strong>订单服务、库存服务、仓储服务、积分服务</strong>。整个流程的大体思路如下：</p><p>用户针对一个订单完成支付之后，就会去找订单服务，更新订单状态</p><p>订单服务调用库存服务，完成相应功能</p><p>订单服务调用仓储服务，完成相应功能</p><p>订单服务调用积分服务，完成相应功能</p><p>至此，整个支付订单的业务流程结束</p><p>下图这张图，清晰表明了各服务间的调用过程：</p><p><img src="/articles/e36292b2/1.jpg" alt></p><p> 好！有了业务场景之后，咱们就一起来看看Spring Cloud微服务架构中，这几个组件如何相互协作，各自发挥的作用以及其背后的原理。</p><h2 id="Spring-Cloud核心组件"><a href="#Spring-Cloud核心组件" class="headerlink" title="Spring Cloud核心组件"></a>Spring Cloud核心组件</h2><h4 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h4><p>咱们来考虑第一个问题：订单服务想要调用库存服务、仓储服务，或者是积分服务，怎么调用？</p><p>订单服务压根儿就不知道人家库存服务在哪台机器上啊！他就算想要发起一个请求，都不知道发送给谁，有心无力！</p><p>这时候，就轮到Spring Cloud Eureka出场了。Eureka是微服务架构中的注册中心，专门负责服务的注册与发现。</p><p>咱们来看看下面的这张图，结合图来仔细剖析一下整个流程： </p><p><img src="/articles/e36292b2/2.png" alt></p><p>如上图所示，库存服务、仓储服务、积分服务中都有一个Eureka Client组件，这个组件专门负责将这个服务的信息注册到Eureka Server中。说白了，就是告诉Eureka Server，自己在哪台机器上，监听着哪个端口。而Eureka Server是一个注册中心，里面有一个注册表，保存了各服务所在的机器和端口号</p><p>订单服务里也有一个Eureka Client组件，这个Eureka Client组件会找Eureka Server问一下：库存服务在哪台机器啊？监听着哪个端口啊？仓储服务呢？积分服务呢？然后就可以把这些相关信息从Eureka Server的注册表中拉取到自己本地缓存起来。</p><p>这时如果订单服务想要调用库存服务，不就可以找自己本地的Eureka Client问一下库存服务在哪台机器？监听哪个端口吗？收到响应后，紧接着就可以发送一个请求过去，调用库存服务扣减库存的那个接口！同理，如果订单服务要调用仓储服务、积分服务，也是如法炮制。</p><p><strong>总结一下</strong>：</p><ul><li><p>Eureka Client：负责将这个服务的信息注册到Eureka Server中</p></li><li><p>Eureka Server：注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号</p></li></ul><h4 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h4><p>现在订单服务确实知道库存服务、积分服务、仓库服务在哪里了，同时也监听着哪些端口号了。但是新问题又来了：难道订单服务要自己写一大堆代码，跟其他服务建立网络连接，然后构造一个复杂的请求，接着发送请求过去，最后对返回的响应结果再写一大堆代码来处理吗？</p><p>这是上述流程翻译的代码片段，咱们一起来看看，体会一下这种绝望而无助的感受！！！</p><p><strong>友情提示，前方高能</strong>：</p><p><img src="/articles/e36292b2/3.png" alt></p><p> 看完上面那一大段代码，有没有感到后背发凉、一身冷汗？实际上你进行服务间调用时，如果每次都手写代码，代码量比上面那段要多至少几倍，所以这个事儿压根儿就不是地球人能干的。</p><p>既然如此，那怎么办呢？别急，Feign早已为我们提供好了优雅的解决方案。来看看如果用Feign的话，你的订单服务调用库存服务的代码会变成啥样？</p><p><img src="/articles/e36292b2/4.png" alt></p><p>看完上面的代码什么感觉？是不是感觉整个世界都干净了，又找到了活下去的勇气！没有底层的建立连接、构造请求、解析响应的代码，直接就是用注解定义一个 FeignClient接口，然后调用那个接口就可以了。人家Feign Client会在底层根据你的注解，跟你指定的服务建立连接、构造请求、发起靕求、获取响应、解析响应，等等。这一系列脏活累活，人家Feign全给你干了。</p><p>那么问题来了，Feign是如何做到这么神奇的呢？很简单，<strong>Feign的一个关键机制就是使用了动态代理</strong>。咱们一起来看看下面的图，结合图来分析：</p><ul><li><p>首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理</p></li><li><p>接着你要是调用那个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心</p></li><li><p>Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址</p></li><li><p>最后针对这个地址，发起请求、解析响应</p></li></ul><p> <img src="/articles/e36292b2/5.png" alt></p><h4 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h4><p>说完了Feign，还没完。现在新的问题又来了，如果人家库存服务部署在了5台机器上，如下所示：</p><p>192.168.169:9000</p><p>192.168.170:9000</p><p>192.168.171:9000</p><p>192.168.172:9000</p><p>192.168.173:9000</p><p>这下麻烦了！人家Feign怎么知道该请求哪台机器呢？</p><ul><li>这时Spring Cloud Ribbon就派上用场了。Ribbon就是专门解决这个问题的。它的作用是负载均衡，会帮你在每次请求时选择一台机器，均匀的把请求分发到各个机器上</li></ul><ul><li>Ribbon的负载均衡默认使用的最经典的Round Robin轮询算法。这是啥？简单来说，就是如果订单服务对库存服务发起10次请求，那就先让你请求第1台机器、然后是第2台机器、第3台机器、第4台机器、第5台机器，接着再来—个循环，第1台机器、第2台机器。。。以此类推。</li></ul><p> 此外，Ribbon是和Feign以及Eureka紧密协作，完成工作的，具体如下：</p><ul><li><p>首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。</p></li><li><p>然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器</p></li><li><p>Feign就会针对这台机器，构造并发起请求。</p></li></ul><p> 对上述整个过程，再来一张图，帮助大家更深刻的理解：</p><p><img src="/articles/e36292b2/6.png" alt></p><h4 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h4><p>在微服务架构里，一个系统会有很多的服务。以本文的业务场景为例：订单服务在一个业务流程里需要调用三个服务。现在假设订单服务自己最多只有100个线程可以处理请求，然后呢，积分服务不幸的挂了，每次订单服务调用积分服务的时候，都会卡住几秒钟，然后抛出—个超时异常。</p><p><strong>咱们一起来分析一下，这样会导致什么问题？</strong></p><ol><li><p>如果系统处于高并发的场景下，大量请求涌过来的时候，订单服务的100个线程都会卡在请求积分服务这块。导致订单服务没有一个线程可以处理请求</p></li><li><p>然后就会导致别人请求订单服务的时候，发现订单服务也挂了，不响应任何请求了</p></li></ol><p>上面这个，<strong>就是微服务架构中恐怖的服务雪崩问题</strong>，如下图所示：</p><p><img src="/articles/e36292b2/7.jpg" alt></p><p>如上图，这么多服务互相调用，要是不做任何保护的话，某一个服务挂了，就会引起连锁反应，导致别的服务也挂。比如积分服务挂了，会导致订单服务的线程全部卡在请求积分服务这里，没有一个线程可以工作，瞬间导致订单服务也挂了，别人请求订单服务全部会卡住，无法响应。</p><p><strong>但是我们思考一下，就算积分服务挂了，订单服务也可以不用挂啊！</strong>为什么？</p><ul><li><p>我们结合业务来看：支付订单的时候，只要把库存扣减了，然后通知仓库发货就OK了</p></li><li><p>如果积分服务挂了，大不了等他恢复之后，慢慢人肉手工恢复数据！为啥一定要因为一个积分服务挂了，就直接导致订单服务也挂了呢？不可以接受！</p></li></ul><p><strong>现在问题分析完了，如何解决</strong>？</p><p>这时就轮到Hystrix闪亮登场了。Hystrix是隔离、熔断以及降级的一个框架。啥意思呢？说白了，Hystrix会搞很多个小小的线程池，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务。</p><p><strong>打个比方：现在很不幸，积分服务挂了，会咋样？</strong></p><p>当然会导致订单服务里的那个用来调用积分服务的线程都卡死不能工作了啊！但是由于订单服务调用库存服务、仓储服务的这两个线程池都是正常工作的，所以这两个服务不会受到任何影响。</p><p>这个时候如果别人请求订单服务，订单服务还是可以正常调用库存服务扣减库存，调用仓储服务通知发货。只不过调用积分服务的时候，每次都会报错。但是<strong>如果积分服务都挂了，每次调用都要去卡住几秒钟干啥呢？有意义吗？当然没有！</strong>所以我们直接对积分服务熔断不就得了，比如在5分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟，这个过程，就是所谓的熔断！</p><p><strong>那人家又说，兄弟，积分服务挂了你就熔断，好歹你干点儿什么啊！</strong>别啥都不干就直接返回啊？没问题，咱们就来个降级：每次调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。这个过程，就是所谓的降级。</p><p>为帮助大家更直观的理解，接下来用一张图，梳理一下Hystrix隔离、熔断和降级的全流程：</p><p><img src="/articles/e36292b2/8.png" alt></p><h4 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h4><p>说完了Hystrix，接着给大家说说最后一个组件：Zuul，也就是微服务网关。这个组件是负责网络路由的。不懂网络路由？行，那我给你说说，如果没有Zuul的日常工作会怎样？</p><p>假设你后台部署了几百个服务，现在有个前端兄弟，人家请求是直接从浏览器那儿发过来的。打个比方：人家要请求一下库存服务，你难道还让人家记着这服务的名字叫做inventory-service？部署在5台机器上？就算人家肯记住这一个，你后台可有几百个服务的名称和地址呢？难不成人家请求一个，就得记住一个？你要这样玩儿，那真是友谊的小船，说翻就翻！</p><p>上面这种情况，压根儿是不现实的。所以一般微服务架构中都必然会设计一个网关在里面，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。</p><p>而且有一个网关之后，还有很多好处，比如可以做统一的降级、限流、认证授权、安全，等等。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>最后再来总结一下，上述几个Spring Cloud核心组件，在微服务架构中，分别扮演的角色：</p><ul><li><strong>Eureka</strong>：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里</li><li><strong>Ribbon</strong>：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台</li><li><strong>Feign</strong>：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求</li><li><strong>Hystrix</strong>：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题</li><li><strong>Zuul</strong>：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务</li></ul><p>以上就是我们通过一个电商业务场景，阐述了Spring Cloud微服务架构几个核心组件的底层原理。</p><p> <img src="/articles/e36292b2/9.png" alt></p><p>文字总结还不够直观？没问题！我们将Spring Cloud的5个核心组件通过一张图串联起来，再来直观的感受一下其底层的架构原理：</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;毫无疑问，Spring Cloud是目前微服务架构领域的翘楚，无数的书籍博客都在讲解这个技术。不过大多数讲解还停留在对Spring Cloud功能使用的层面，其底层的很多原理，很多人可能并不知晓。因此本文将通过大量的手绘图，给大家谈谈Spring Cloud微服务架构的底层原理。&lt;/p&gt;
&lt;p&gt;实际上，Spring Cloud是一个全家桶式的技术栈，包含了很多组件。本文先从其最核心的几个组件入手，来剖析一下其底层的工作原理。也就是Eureka、Ribbon、Feign、Hystrix、Zuul这几个组件。&lt;/p&gt;
    
    </summary>
    
      <category term="应用运维" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Java" scheme="http://wandouduoduo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus基本原理和使用</title>
    <link href="http://wandouduoduo.github.io/articles/65b2b731.html"/>
    <id>http://wandouduoduo.github.io/articles/65b2b731.html</id>
    <published>2019-07-17T11:21:08.000Z</published>
    <updated>2019-08-07T02:06:43.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Prometheus是由SoundCloud开发的开源监控报警系统和时序列数据库(TSDB)。Prometheus使用Go语言开发，是Google BorgMon监控系统的开源版本。</p><p>2016年由Google发起Linux基金会旗下的原生云基金会(Cloud Native Computing Foundation), 将Prometheus纳入其下第二大开源项目。Prometheus目前在开源社区相当活跃。</p><p>Prometheus和Heapster(Heapster是K8S的一个子项目，用于获取集群的性能数据。)相比功能更完善、更全面。Prometheus性能也足够支撑上万台规模的集群。</p> <a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/prometheus/prometheus" target="_blank" rel="noopener">https://github.com/prometheus/prometheus</a></p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://prometheus.io/" target="_blank" rel="noopener">https://prometheus.io/</a></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>多维度数据模型。<br>灵活的查询语言。<br>不依赖分布式存储，单个服务器节点是自主的。<br>通过基于HTTP的pull方式采集时序数据。<br>可以通过中间网关进行时序列数据推送。<br>通过服务发现或者静态配置来发现目标服务对象。<br>支持多种多样的图表和界面展示，比如Grafana等。</p><h2 id="相关组件："><a href="#相关组件：" class="headerlink" title="相关组件："></a>相关组件：</h2><p>Prometheus生态系统由多个组件组成，它们中的一些是可选的。多数Prometheus组件是Go语言写的，这使得这些组件很容易编译和部署。</p><p><strong>Prometheus Server</strong><br>主要负责数据采集和存储，提供PromQL查询语言的支持。</p><p><strong>客户端SDK</strong><br>官方提供的客户端类库有go、java、scala、python、ruby，其他还有很多第三方开发的类库，支持nodejs、php、erlang等。</p><p><strong>Push Gateway</strong><br>支持临时性Job主动推送指标的中间网关。</p><p><strong>PromDash</strong><br>使用Rails开发可视化的Dashboard，用于可视化指标数据。</p><p><strong>Exporter</strong><br>Exporter是Prometheus的一类数据采集组件的总称。它负责从目标处搜集数据，并将其转化为Prometheus支持的格式。与传统的数据采集组件不同的是，它并不向中央服务器发送数据，而是等待中央服务器主动前来抓取。</p><p>Prometheus提供多种类型的Exporter用于采集各种不同服务的运行状态。目前支持的有数据库、硬件、消息中间件、存储系统、HTTP服务器、JMX等。</p><p><strong>alertmanager</strong><br>警告管理器，用来进行报警。</p><p><strong>prometheus_cli</strong><br>命令行工具。</p><p><strong>其他辅助性工具</strong><br>多种导出工具，可以支持Prometheus存储数据转化为HAProxy、StatsD、Graphite等工具所需要的数据存储格式。</p><h2 id="架构："><a href="#架构：" class="headerlink" title="架构："></a>架构：</h2><p>下面这张图说明了Prometheus的整体架构，以及生态中的一些组件作用:</p><p><img src="/articles/65b2b731/1.png" alt></p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>是通过HTTP协议周期性抓取被监控组件的状态，任意组件只要提供对应的HTTP接口就可以接入监控。不需要任何SDK或者其他的集成过程。这样做非常适合做虚拟化环境监控系统，比如VM、Docker、Kubernetes等。输出被监控组件信息的HTTP接口被叫做exporter 。目前互联网公司常用的组件大部分都有exporter可以直接使用，比如Varnish、Haproxy、Nginx、MySQL、Linux系统信息(包括磁盘、内存、CPU、网络等等)。</p><p>Prometheus服务过程大概是这样：</p><p>Prometheus Daemon负责定时去目标上抓取metrics(指标)数据，每个抓取目标需要暴露一个http服务的接口给它定时抓取。Prometheus支持通过配置文件、文本文件、Zookeeper、Consul、DNS SRV Lookup等方式指定抓取目标。Prometheus采用PULL的方式进行监控，即服务器可以直接通过目标PULL数据或者间接地通过中间网关来Push数据。</p><p>Prometheus在本地存储抓取的所有数据，并通过一定规则进行清理和整理数据，并把得到的结果存储到新的时间序列中。</p><p>Prometheus通过PromQL和其他API可视化地展示收集的数据。Prometheus支持很多方式的图表可视化，例如Grafana、自带的Promdash以及自身提供的模版引擎等等。Prometheus还提供HTTP API的查询方式，自定义所需要的输出。</p><p>PushGateway支持Client主动推送metrics到PushGateway，而Prometheus只是定时去Gateway上抓取数据。</p><p>Alertmanager是独立于Prometheus的一个组件，可以支持Prometheus的查询语句，提供十分灵活的报警方式。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p><strong>适用的场景</strong><br>Prometheus在记录纯数字时间序列方面表现非常好。它既适用于面向服务器等硬件指标的监控，也适用于高动态的面向服务架构的监控。对于现在流行的微服务，Prometheus的多维度数据收集和数据筛选查询语言也是非常的强大。Prometheus是为服务的可靠性而设计的，当服务出现故障时，它可以使你快速定位和诊断问题。它的搭建过程对硬件和服务没有很强的依赖关系。</p><p><strong>不适用的场景</strong></p><p>Prometheus它的价值在于可靠性，甚至在很恶劣的环境下，你都可以随时访问它和查看系统服务各种指标的统计信息。 如果你对统计数据需要100%的精确，它并不适用，例如：它不适用于实时计费系统。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Prometheus是由SoundCloud开发的开源监控报警系统和时序列数据库(TSDB)。Prometheus使用Go语言开发，是Google BorgMon监控系统的开源版本。&lt;/p&gt;
&lt;p&gt;2016年由Google发起Linux基金会旗下的原生云基金会(Cloud Native Computing Foundation), 将Prometheus纳入其下第二大开源项目。Prometheus目前在开源社区相当活跃。&lt;/p&gt;
&lt;p&gt;Prometheus和Heapster(Heapster是K8S的一个子项目，用于获取集群的性能数据。)相比功能更完善、更全面。Prometheus性能也足够支撑上万台规模的集群。&lt;/p&gt;
    
    </summary>
    
      <category term="应用运维" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/"/>
    
      <category term="监控积累" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/%E7%9B%91%E6%8E%A7%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="Prometheus" scheme="http://wandouduoduo.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>openfalcon的基本原理和使用</title>
    <link href="http://wandouduoduo.github.io/articles/cd887590.html"/>
    <id>http://wandouduoduo.github.io/articles/cd887590.html</id>
    <published>2019-07-17T09:07:16.000Z</published>
    <updated>2019-08-07T02:06:43.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>本篇文章介绍下openfalcon的基本原理和使用，粒度相对较粗，主要目的是使大家迅速掌握open-falcon的数据模型、功能模块、运作流程和使用方法。</p><a id="more"></a><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h2><p>Open-Falcon 是小米研发的一款开源的互联网企业级监控系统解决方案，目前小米、金山云、美团、京东金融、滴滴等公司有在使用。</p><p>下面我们遵循着问题来展开整篇文章。<strong>首先，open-falcon能做什么？</strong></p><p>主要特点有</p><p>  ①数据采集免配置：agent自发现、支持Plugin、主动推送模式</p><p>  ②容量水平扩展：生产环境每秒50万次数据收集、告警、存储、绘图，可持续水平扩展。</p><p>  ③告警策略自发现：Web界面、支持策略模板、模板继承和覆盖、多种告警方式、支持回调动作。</p><p>  ④告警设置人性化：支持最大告警次数、告警级别设置、告警恢复通知、告警暂停、不同时段不同阈</p><p>​      值、支持维护周期，支持告警合并。</p><p>  ⑤历史数据高效查询：秒级返回上百个指标一年的历史数据。</p><p>  ⑥Dashboard人性化：多维度的数据展示，用户自定义Dashboard等功能。</p><p>  ⑦架构设计高可用：整个系统无核心单点，易运维，易部署。</p><p><strong>其次，openfalcon能对哪些项目做监控 ？</strong></p><p> 1）基础监控。</p><p>   比如CPU、Load、内存、磁盘、IO、网络相关、内核参数、ss 统计输出、端口存活状态、进程存活状态、核心服务的进程存活信息采集、关键业务进程资源消耗、NTP offset采集、DNS解析采集，这些指标，都是open-falcon的agent组件直接支持的。</p><p>  2）业务应用监控。</p><p>   比如我的应用服务部署上线后，需要统计某个接口的平均耗时、调用次数、成功率等信息，这些属于业务应用的监控。这里需要研发人员编写脚本等方式来收集数据，然后发送到open-falcon的transfer组件。</p><p>  3）第三方开源软件监控。</p><p>  比如mysql、lvs、nginx、redis、mq等，需单独编写采集脚本或插件，这些常见的软件，一般开源社区都有提供相应的脚本。</p><p>  这里有个openfalcon与其他一些监控软件的对比，</p><p><img src="/articles/cd887590/1.png" alt></p><p><strong>个人觉得，falcon比较大的优势在于扩展性和灵活性方面。</strong></p><h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a><strong>技术架构</strong></h2><p>涉及架构或结构时，图是比较好的展示方式，下图摘自官网，可以看出组件及组件间协作。</p><p><img src="/articles/cd887590/2.png" alt></p><p>绿色的粗线表示数据传输流程，橙黄色虚线表示控制流（策略，告警），浅蓝色虚线标识查询流程；</p><p>下图是一个相对规整的数据流图，更有助于理解：</p><p><img src="/articles/cd887590/3.png" alt></p><p>具体而言，整体的运作流程如下：</p><p>1、目标服务器运行agent </p><p>2、agent采集各类监控项数值，传给transfer</p><p>3、transfer校验和整理监控项数值，做一致性hash分片，传给对应的judge模块以验证是否触发告警 </p><p>4、transfer整理监控项数值，做一致性hash分片，传输给graph以进行数据的存储 </p><p>5、judge根据具体报警策略或阈值进行告警判断，如触发告警则组装告警event事件，写入缓存队列。 </p><p>6、alarm和sender根据event事件中的判定结果，执行event，像用户组发送短信或邮件。 </p><p>7、graph收到监控项数据后，将数据存储成RRD文件格式，进行归档，并提供查询接口。 </p><p>8、query将调用graph的查询接口，将监控数据传送到dashboard以进行页面展示。 </p><p>9、dashboard则渲染页面，展示曲线报表图等。 </p><p>10、portal提供页面供用户配置机器分组、报警策略、表达式、nodata等配置。</p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a><strong>数据模型</strong></h2><p>灵活强大的数据模型能提高监控系统的使用效率和灵活性（这小节提到的数据模型应该叫监控项数据模型），<strong>open-falcon的数据模型长什么样？设计初衷又是什么？</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">open-falcon的"监控项"模型如下，</span><br><span class="line">&#123;</span><br><span class="line">       metric: cpu.busy,               // 监控项名称</span><br><span class="line"></span><br><span class="line">       endpoint: open-falcon-host,     // 目标服务器的主机名</span><br><span class="line"></span><br><span class="line">       tags: srv=falcon,group=az1,     // tag标签，作用是聚合和归类，在配报警策略时会比较方便。</span><br><span class="line"></span><br><span class="line">       value: 10,                      // 监控项数值</span><br><span class="line"></span><br><span class="line">       timestamp: `date +%s`,          // 采集时间</span><br><span class="line"></span><br><span class="line">       counterType: GAUGE,             //  监控项类型。 </span><br><span class="line"></span><br><span class="line">       step: 60                        // 采集间隔。 秒。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模型的主要好处：一是方便从多个维度来配置告警，二是可以灵活的进行自主数据采集。</p><pre><code>第一点，比如tag的使用起到了给机器进行归类的作用，比如有3台机器：host1、host2和host3，如果tags依次配置为&quot;group=java&quot;, &quot;group=java&quot;和&quot;group=erlang&quot;，那么配置报警策略&quot;metric=cpu/group=java“时就只会对java标签的机器（即host1，host2)生效。第二点，由于agent会自发现的采集很多基本的系统指标，但是对业务应用等需要研发人员自己写脚本收集和上报。这里openfalcon定义了监控项模型，相当于定义了一个规范，当研发人员需要监控某个对象（比如mysql、redis等），只需采集数据，并遵守规范包装成监控项模型，再上报即可。</code></pre><p><strong>open-falcon使用的监控项有哪些类型 ？</strong></p><p>主要有三种：</p><p>(1) GAUGE：实测值，直接使用采集的原始数值，比如气温；</p><p>(2) COUNTER：记录连续增长的数据，只增不减。比如汽车行驶里程，网卡流出流量，cpu_idle等；</p><p>(3) DERIVE：变化率，类似COUNTER ，但是可增可减。</p><h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a><strong>主要模块</strong></h2><h4 id="agent"><a href="#agent" class="headerlink" title="agent"></a><strong>agent</strong></h4><ul><li><strong>首先，什么是Agent？</strong></li></ul><p>agent是go开发的daemon程序，用于自发现的采集机器的各种数据和指标。部署在目标机器上，无需在server端进行任何配置，安装后启动即工作，是open-falcon的”数据采集者”。</p><ul><li><strong>主要功能？</strong></li></ul><p>​       1）自发现的采集各类数据和指标，上报transfer；</p><p>​       2）与hbs进行心跳连接通信，上报主机状态，同步插件和监控进程、监控端口；</p><ul><li><strong>可采集的数据有哪些？</strong></li></ul><p>​        基础监控项(硬件,负载)、业务应用监控数据、各种开源软件监控数据等。</p><ul><li><p><strong>falcon是如何采集的？</strong></p><p>   1）基础监控</p><p>​    一般是读系统文件或执行基本命令，然后对原始值进行处理。比如cpu和内存信息是通过读取/proc/stat和/proc/meminfo获得；端口监控，是通过ss –ln 来判断指定端口是否处于listen状态；</p><p>   2）业务应用监控</p><p>   一般由”插件”或”采集脚本”实现，需自己编写。比如接口的调用次数、耗时、失败次数、成功次数都属于这类。(日志、基础统计工具)</p><p>   3）开源软件监控</p><p>   一般开源社区都有提供采集脚本</p></li><li><p><strong>如何扩展agent – 插件？</strong></p><p>除了基础监控项，有时用户想扩展agent的功能以采集更多指标，openfalcon提供了插件机制。插件的使用可以参考官方git文档，下面摘抄了作者们的一段话，其实就是一些采集脚本及同步执行的方式。</p><p>  “插件设计思路：</p><p>  a) 写一个采集数据的脚本</p><p>  b) 把脚本分发到需要采集数据的机器上</p><p>  c) 写一个cron每隔一段时间去跑这个脚本</p><p>  d) 收集脚本的输出，调用server的接口去push数据</p><p>  e) 根据需求相应的对脚本做上线、下线、升级”</p></li><li><p><strong>agent的工作流程：</strong></p><p><img src="/articles/cd887590/4.png" alt></p></li></ul><h4 id="Transfer组件"><a href="#Transfer组件" class="headerlink" title="Transfer组件"></a><strong>Transfer组件</strong></h4><ul><li><p><strong>什么是transfer？</strong></p><p>open-falcon的后端门户，监控数据的中转接点。</p></li><li><p><strong>transfer的职责角色？</strong></p><p>提供数据接收接口和自定义脚本push数据；</p></li></ul><p>​        根据一致性hash算法将内存队列中的数据发送给graph和judge模块；(重点)</p><p>​        为每个后端实例创建一个 定长Queue；</p><p>​        为每个后端实例维护一个rpc连接池；</p><p><img src="/articles/cd887590/5.png" alt></p><p>这里每个后端的graph或judge实例都建立了一个rpc连接池和一个定长Queue队列。</p><p>有两个小点这里提下：</p><p>1，定长Queue队列目的是应对高峰流量，丢失一部分高峰时段的数据保证了后端的graph和judge组件不受影响；</p><ol start="2"><li>v1.0版本的openfalcon中，每个graph实例可以有多个ip而且transfer会给每个ip发送相同的一份数据，但是judge中每个实例只能有1个ip。</li></ol><ul><li><p><strong>transfer的工作流程？</strong></p><p><img src="/articles/cd887590/6.png" alt></p></li></ul><h4 id="graph组件"><a href="#graph组件" class="headerlink" title="graph组件"></a><strong>graph组件</strong></h4><ul><li><strong>什么是graph？graph的职责？</strong></li></ul><p>​      存储监控数据、提供监控数据的高效查询接口。</p><ul><li><p><strong>graph的架构图(摘自项目git)：</strong></p><p><img src="/articles/cd887590/7.png" alt></p></li></ul><h4 id="judge-amp-alarm-amp-sender组件"><a href="#judge-amp-alarm-amp-sender组件" class="headerlink" title="judge&amp;alarm&amp;sender组件"></a><strong>judge&amp;alarm&amp;sender组件</strong></h4><p>这三个组件是报警的链路，负责判断是否触发报警，理论上可以进化成一个模块。感兴趣的可以看代码，很多匹配逻辑。</p><p>judge: 记载策略到缓存，判断监控项是否触发告警策略，发告警事件；</p><p>alarm&amp;sender: 读取告警事件；发邮件、短信等；</p><h4 id="hbs组件"><a href="#hbs组件" class="headerlink" title="hbs组件"></a><strong>hbs组件</strong></h4><ul><li><strong>什么是hbs，hbs的职责？</strong></li></ul><p>​      heart beat server，心跳服务器，更多承担”配置中心”的角色。</p><p>​      1）Agent可以从hbs同步”报警策略”、”进程存活监控”、”端口存活监控”等信息。</p><p>​      2）agent定期发送心跳信息，hbs负责维护host表；</p><ul><li><p><strong>hbs的工作流程：</strong></p><p><img src="/articles/cd887590/8.png" alt></p></li></ul><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a><strong>如何使用？</strong></h2><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>  (1)、如何监控基本监控项？</p><p>  (2)、如何使用插件，监控“第三方应用”？如何监控“端口/进程”？</p><p>  (3)、如何配置“告警规则”?</p><p>  (4)、如何使用hostGroup、template、expression、nodata、uic？</p><p>  (5)、如何更好管理机器？如hostName、hostGroup的命名约定；</p><h4 id="先要理解的一些概念"><a href="#先要理解的一些概念" class="headerlink" title="先要理解的一些概念"></a><strong>先要理解的一些概念</strong></h4><p>  (1)、机器分组</p><p>  (2)、用户组</p><p>  (3)、模板</p><p>  (4)、表达式</p><p>  (5)、报警策略</p><p>  (6)、回调动作</p><h4 id="如何采集基本监控项-？"><a href="#如何采集基本监控项-？" class="headerlink" title="如何采集基本监控项 ？"></a><strong>如何采集基本监控项 ？</strong></h4><p> 在目标机器上部署agent，正确配置，启动即可；</p><h4 id="如何监控“第三方应用”，如mysql-lvs-nginx？"><a href="#如何监控“第三方应用”，如mysql-lvs-nginx？" class="headerlink" title="如何监控“第三方应用”，如mysql/lvs/nginx？"></a><strong>如何监控“第三方应用”，如mysql/lvs/nginx？</strong></h4><p>自己写脚本，上报到open-falcon；或者使用开源的插件或脚本；</p><p> <a href="https://book.open-falcon.org/zh/philosophy/data-collect.html" target="_blank" rel="noopener">https://book.open-falcon.org/zh/philosophy/data-collect.html</a></p><h4 id="如何监控“端口存活”、“进程存活”-？"><a href="#如何监控“端口存活”、“进程存活”-？" class="headerlink" title="如何监控“端口存活”、“进程存活” ？"></a><strong>如何监控“端口存活”、“进程存活” ？</strong></h4><p>在port页面，新增expression或template，给指定进程或端口配置报警策略；</p><h4 id="使用机器分组和报警策略模板？"><a href="#使用机器分组和报警策略模板？" class="headerlink" title="使用机器分组和报警策略模板？"></a><strong>使用机器分组和报警策略模板？</strong></h4><p>这里刚开始接触时觉得特别麻烦，后来拉出代码，分析其关联关系，梳理出了模型及关系图，一切变得清晰。下图依次是：hostgroup机器组管理、Tempalte报警策略模板、模型关系UML图。重点理解UML图，然后去页面上操作和比较下。</p><p><img src="/articles/cd887590/9.png" alt></p><p><img src="/articles/cd887590/10.png" alt></p><p><img src="/articles/cd887590/11.png" alt></p><h4 id="如何使用表达式-？“策略表达式”与”策略模板”的区别？"><a href="#如何使用表达式-？“策略表达式”与”策略模板”的区别？" class="headerlink" title="如何使用表达式 ？“策略表达式”与”策略模板”的区别？"></a><strong>如何使用表达式 ？“策略表达式”与”策略模板”的区别？</strong></h4><p>表达式比较简洁，在结合tag时可以使用策略表达式。</p><p>当无法区分类别时，比如所有监控项都没有加tag，只有进行人工分类，即使用”机器分组”，然后将”策略模板”绑定到”机器分组”。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h2><p>其他需要自己翻文档或代码了，比如nodata，aggravation等等。通过这篇文章，希望能掌握open-falcon的运作机制，数据模型，如何使用它。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;本篇文章介绍下openfalcon的基本原理和使用，粒度相对较粗，主要目的是使大家迅速掌握open-falcon的数据模型、功能模块、运作流程和使用方法。&lt;/p&gt;
    
    </summary>
    
      <category term="应用运维" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/"/>
    
      <category term="监控积累" scheme="http://wandouduoduo.github.io/categories/%E5%BA%94%E7%94%A8%E8%BF%90%E7%BB%B4/%E7%9B%91%E6%8E%A7%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="Open-falcon" scheme="http://wandouduoduo.github.io/tags/Open-falcon/"/>
    
  </entry>
  
  <entry>
    <title>Rocketchat安装手册</title>
    <link href="http://wandouduoduo.github.io/articles/1f64fa0e.html"/>
    <id>http://wandouduoduo.github.io/articles/1f64fa0e.html</id>
    <published>2019-07-16T11:19:23.000Z</published>
    <updated>2019-08-07T02:06:43.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>本文详细介绍了Chatops的实现服务Rocketchat的安装。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a><strong>方法一：</strong></h4><p><strong>1，启动mongodb实例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker run --name db -d mongo:3.0 --smallfiles`</span><br></pre></td></tr></table></figure><p><strong>2，启动rocketchat server:</strong></p><p>注意替换your_public_ip</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker run --name rocketchat -p 80:3000 --``env` `ROOT_URL=http:``//``&#123;your_public_ip&#125; --link db -d rocket.chat:0.62`</span><br></pre></td></tr></table></figure><p>启动成功后，访问: http://{your_public_ip} 即可。</p><p><strong>3，hubot实例:（最新版本，脚本目录映射有问题，请自行去掉）</strong></p><p>添加robot前，确保server中已添加改账号，并设置了邮件为已验证。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker run -it -e ROCKETCHAT_URL=http:``//``&#123;rocket_chat_server_ip&#125;:&#123;port&#125; \``    ``-e ROCKETCHAT_ROOM=``<span class="string">'general'</span>` `\``    ``-e LISTEN_ON_ALL_PUBLIC=``<span class="literal">true</span>` `\``    ``-e ROCKETCHAT_USER=bot \``    ``-e ROCKETCHAT_PASSWORD=password \``    ``-e ROCKETCHAT_AUTH=password \``    ``-e BOT_NAME=bot \``    ``-e EXTERNAL_SCRIPTS=hubot-pugme,hubot-help \``    ``-``v` `<span class="variable">$PWD</span>``/scripts``:``/home/hubot/scripts` `\``    ``rocketchat``/hubot-rocketchat`</span><br></pre></td></tr></table></figure><p>说明（下面未提及，不用更改）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rocket_chat_server_ip: server地址</span><br><span class="line">ROCKETCHAT_ROOM: 默认加入的channel（房间），可以不填</span><br><span class="line">ROCKETCHAT_USER: robot名字, 例如: cicd-robot, git-merge-robot</span><br><span class="line">ROCKETCHAT_PASSWORD: 密码</span><br><span class="line">$PWD/scripts:/home/hubot/scripts: 本地scripts脚本映射到容器</span><br><span class="line">内</span><br></pre></td></tr></table></figure><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>1，编辑yaml文件</p><p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">db:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  image:</span> <span class="attr">mongo:3.0</span></span><br><span class="line"><span class="attr">  command:</span> <span class="string">mongod</span> <span class="bullet">--smallfiles</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rocketchat:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  image:</span> <span class="string">rocket.chat:0.62</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span> <span class="string">MONGO_URL=mongodb://db:27017/rocketchat</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ROOT_URL=http://10.10.0.137:3000</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span> <span class="string">Accounts_UseDNSDomainCheck=False</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  links:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - db:</span><span class="string">db</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span> <span class="number">3000</span><span class="string">:3000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">hubot:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  image:</span> <span class="string">rocketchat/hubot-rocketchat</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ROCKETCHAT_URL=http://10.10.0.137:3000</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ROCKETCHAT_ROOM=GENERAL</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ROCKETCHAT_USER=Hubot</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span> <span class="string">ROCKETCHAT_PASSWORD=Sun123456</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span> <span class="string">BOT_NAME=Hubot</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span> <span class="string">EXTERNAL_SCRIPTS=hubot-help,hubot-seen,hubot-links,hubot-greetings</span></span><br><span class="line">    </span><br><span class="line"><span class="bullet">    -</span> <span class="string">HUBOT_JENKINS_URL=10.10.0.137:8080</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">    -</span> <span class="string">HUBOT_JENKINS_AUTH=admin:admin123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  links:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    - rocketchat:</span><span class="string">rocketchat</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2, 安装docker-compose</span><br><span class="line">pip install docker-compose</span><br><span class="line">3, 启动容器</span><br><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p>4,  注册管理员账号</p><p><img src="/articles/1f64fa0e/1.png" alt="img"></p><p>5，添加bot账号（账号要和docker-compose中定义的用户名和密码一致）</p><p><img src="/articles/1f64fa0e/2.png" alt="img"></p><p><img src="/articles/1f64fa0e/3.png" alt="img"></p><p><img src="/articles/1f64fa0e/4.png" alt="img"></p><p><img src="/articles/1f64fa0e/5.png" alt="img"></p><p>6，重启所有容器，docker-compose restart</p><p>7,  验证</p><p><img src="/articles/1f64fa0e/6.png" alt="img"></p><p>8，测试脚本sun.coffee</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">(robot)</span> -&gt;</span></span><br><span class="line">  <span class="comment"># 匹配所有 hi 相关的输入，然后发送 hello 到聊天室</span></span><br><span class="line">  robot.hear <span class="regexp">/hi/i</span>, <span class="function"><span class="params">(res)</span> -&gt;</span></span><br><span class="line">    res.send <span class="string">'hello'</span></span><br></pre></td></tr></table></figure><p>9, 复制脚本到容器中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp ./sun.coffee root_hubot_1:/home/hubot/scripts</span><br></pre></td></tr></table></figure><p>10，重启容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker restart root_hubot_1</span><br><span class="line">docker <span class="built_in">exec</span> -u root -it root_hubot_1 /bin/bash</span><br></pre></td></tr></table></figure><p>11，验证</p><p><img src="/articles/1f64fa0e/7.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;本文详细介绍了Chatops的实现服务Rocketchat的安装。&lt;/p&gt;
    
    </summary>
    
      <category term="智能工程" scheme="http://wandouduoduo.github.io/categories/%E6%99%BA%E8%83%BD%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="Ai" scheme="http://wandouduoduo.github.io/tags/Ai/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7下CMDBuild源码安装</title>
    <link href="http://wandouduoduo.github.io/articles/a46a113c.html"/>
    <id>http://wandouduoduo.github.io/articles/a46a113c.html</id>
    <published>2019-07-16T10:12:45.000Z</published>
    <updated>2019-08-07T02:06:43.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>本文对CMDBuild的安装配置进行了详细说明。 </p><a id="more"></a><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>系统：<a href="http://www.linuxidc.com/topicnews.aspx?tid=14" target="_blank" rel="noopener">CentOS</a>-7-x86_64-Everything-1511</p><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p>jdk版本(cmdb推荐版本1.8，采用1.8.0_131)：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a> </p><p>tomcat版本(cmdb推荐版本7.068，采用7.0.79)：<a href="http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz" target="_blank" rel="noopener">http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz</a> </p><p> postgresql版本(cmdb推荐版本9.3，采用9.6.3)：<a href="https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm" target="_blank" rel="noopener">https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm</a> </p><h2 id="Tomcat安装配置"><a href="#Tomcat安装配置" class="headerlink" title="Tomcat安装配置"></a>Tomcat安装配置</h2><h3 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h3><h4 id="1）下载jdk"><a href="#1）下载jdk" class="headerlink" title="1）下载jdk"></a>1）下载jdk</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/</span><br><span class="line">wget http://download.Oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.rpm?AuthParam=1499065226_0efcc513ff7eb3edb189b0ee0eb7f2d1</span><br></pre></td></tr></table></figure><h4 id="2）安装jdk"><a href="#2）安装jdk" class="headerlink" title="2）安装jdk"></a>2）安装jdk</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装完成后可使用<span class="string">"java --version"</span>查看环境是否准备就绪</span></span><br><span class="line">rpm -ivh jdk-8u131-linux-x64.rpm</span><br></pre></td></tr></table></figure><h3 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h3><h4 id="1）下载tomcat"><a href="#1）下载tomcat" class="headerlink" title="1）下载tomcat"></a>1）下载tomcat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注意是下载二进制包，非src包" apache-tomcat-7.0.79-src.tar.gz"</span></span><br><span class="line">wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-7/v7.0.79/bin/apache-tomcat-7.0.79.tar.gz</span><br></pre></td></tr></table></figure><h4 id="2）解压-amp-设置tomcat"><a href="#2）解压-amp-设置tomcat" class="headerlink" title="2）解压&amp;设置tomcat"></a>2）解压&amp;设置tomcat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-7.0.79.tar.gz -C /usr/<span class="built_in">local</span>/</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span><br><span class="line">mv apache-tomcat-7.0.79/ tomcat7/</span><br></pre></td></tr></table></figure><h4 id="3）设置环境变量"><a href="#3）设置环境变量" class="headerlink" title="3）设置环境变量"></a>3）设置环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#"tomcat7.sh"中的"tomcat7"部分自定义</span></span><br><span class="line">vim /etc/profile.d/tomcat7.sh</span><br><span class="line"></span><br><span class="line">CATALINA_HOME=/usr/<span class="built_in">local</span>/tomcat7</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$CATALINA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h4 id="4）设置iptables"><a href="#4）设置iptables" class="headerlink" title="4）设置iptables"></a>4）设置iptables</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tcp5432是postgresql的监听端口，tcp8080是tomcat的监听端口</span></span><br><span class="line">vim /etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 5432 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT</span><br><span class="line"></span><br><span class="line">service iptables restart</span><br></pre></td></tr></table></figure><h4 id="5）设置开机启动（CentOS7-x）"><a href="#5）设置开机启动（CentOS7-x）" class="headerlink" title="5）设置开机启动（CentOS7.x）"></a>5）设置开机启动（CentOS7.x）</h4><p><strong>增加tomcat启动参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件名“setenv.sh”固定，catalina.sh启动的时候会调用；</span></span><br><span class="line"><span class="comment">#“tomcat.pid”文件会在tomcat启动后生成在$TOMCAT_HOME目录下</span></span><br><span class="line">vim /usr/<span class="built_in">local</span>/tomcat7/bin/setenv.sh</span><br><span class="line"><span class="comment">#add tomcat pid  </span></span><br><span class="line">CATALINA_PID=<span class="string">"<span class="variable">$CATALINA_BASE</span>/tomcat.pid"</span></span><br></pre></td></tr></table></figure><p><strong>增加tomcat.service</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#“tomcat.service”中的“tomcat”部分自定义；</span></span><br><span class="line"><span class="comment">#或者在/etc/rc.d/rc.local添加启动脚本。</span></span><br><span class="line">vim /usr/lib/systemd/system/tomcat.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Tomcat  </span><br><span class="line">After=syslog.target network.target remote-fs.target nss-lookup.target  </span><br><span class="line">   </span><br><span class="line">[Service]  </span><br><span class="line">Type=forking  </span><br><span class="line">PIDFile=/usr/<span class="built_in">local</span>/tomcat7/tomcat.pid</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/tomcat7/bin/startup.sh</span><br><span class="line">ExecReload=/bin/<span class="built_in">kill</span> -s HUP <span class="variable">$MAINPID</span>  </span><br><span class="line">ExecStop=/bin/<span class="built_in">kill</span> -s QUIT <span class="variable">$MAINPID</span>  </span><br><span class="line">PrivateTmp=<span class="literal">true</span>  </span><br><span class="line">   </span><br><span class="line">[Install]  </span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> tomcat.service</span><br></pre></td></tr></table></figure><h4 id="6）启动-amp-验证tomcat"><a href="#6）启动-amp-验证tomcat" class="headerlink" title="6）启动&amp;验证tomcat"></a>6）启动&amp;验证tomcat</h4><h5 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a><strong>启动tomcat</strong></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#或者使用systemctl命令</span></span><br><span class="line">catalina.sh start</span><br></pre></td></tr></table></figure><h5 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp</span><br></pre></td></tr></table></figure><h5 id="web访问"><a href="#web访问" class="headerlink" title="web访问"></a>web访问</h5><p>浏览器：<a href="http://ip:8080" target="_blank" rel="noopener">http://ip:8080</a></p><h2 id="部署cmdbuild"><a href="#部署cmdbuild" class="headerlink" title="部署cmdbuild"></a>部署cmdbuild</h2><h3 id="下载cmdbbuild"><a href="#下载cmdbbuild" class="headerlink" title="下载cmdbbuild"></a>下载cmdbbuild</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">wget https://ncu.dl.sourceforge.net/project/cmdbuild/2.4.3/cmdbuild-2.4.3.zip</span><br></pre></td></tr></table></figure><h3 id="部署cmdbuild-1"><a href="#部署cmdbuild-1" class="headerlink" title="部署cmdbuild"></a>部署cmdbuild</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unzip cmdbuild-2.4.3.zip</span><br><span class="line"><span class="built_in">cd</span> cmdbuild-2.4.3</span><br><span class="line"></span><br><span class="line"><span class="comment">#复制解压目录下的“cmdbuild-2.4.3.war”到$TOMCAT_HOME的webapps目录下，并更名为” cmdbuild.war”;</span></span><br><span class="line"><span class="comment">#复制解压目录下的“extras/tomcat-libs/6.0\ or\ higher/postgresql-9.4.1207.jar”到$TOMCAT_HOME的lib目录下，版本与postgresql不一致可忽略;</span></span><br><span class="line"><span class="comment">#配置后需要重启tomcat，war包在tomcat启动会被解析</span></span><br><span class="line">cp cmdbuild-2.4.3.war /usr/<span class="built_in">local</span>/tomcat7/webapps/cmdbuild.war</span><br><span class="line">cp extras/tomcat-libs/6.0\ or\ higher/postgresql-9.4.1207.jar /usr/<span class="built_in">local</span>/tomcat7/lib/</span><br></pre></td></tr></table></figure><h2 id="设置PostgreSQL"><a href="#设置PostgreSQL" class="headerlink" title="设置PostgreSQL"></a>设置PostgreSQL</h2><p>PostgreSQL安装略</p><h3 id="设置pg-hba-conf"><a href="#设置pg-hba-conf" class="headerlink" title="设置pg_hba.conf"></a>设置pg_hba.conf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /var/lib/pgsql/9.6/data/pg_hba.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># "local" is for Unix domain socket connections only</span></span><br><span class="line"><span class="built_in">local</span>   all             all                                     md5</span><br><span class="line"><span class="comment"># IPv4 local connections:</span></span><br><span class="line">host    all             all             127.0.0.1/32            md5</span><br><span class="line"></span><br><span class="line">systemctl restart postgresql-9.6</span><br></pre></td></tr></table></figure><h3 id="创建cmdbuild数据库与账号"><a href="#创建cmdbuild数据库与账号" class="headerlink" title="创建cmdbuild数据库与账号"></a>创建cmdbuild数据库与账号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">su - postgres</span><br><span class="line"></span><br><span class="line">-bash-4.2$ psql</span><br><span class="line">postgres=<span class="comment"># create user cmdbadmin with password 'cmdbadmin@123';</span></span><br><span class="line">postgres=<span class="comment"># create database cmdbuild owner cmdbadmin;</span></span><br><span class="line">postgres=<span class="comment"># grant all privileges on database cmdbuild to cmdbadmin;</span></span><br></pre></td></tr></table></figure><h3 id="导入数据表"><a href="#导入数据表" class="headerlink" title="导入数据表"></a>导入数据表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#此数据表是cmdb安装包中自带的1个demo表；</span></span><br><span class="line"><span class="comment">#注意导入的数据库</span></span><br><span class="line">su - postgres</span><br><span class="line"></span><br><span class="line">-bash-4.2$ psql -U cmdbadmin -d cmdbuild -f /usr/<span class="built_in">local</span>/tomcat7/webapps/cmdbuild/WEB-INF/sql/sample_schemas/demo_schema.sql</span><br><span class="line">Password <span class="keyword">for</span> user cmdbadmin:</span><br></pre></td></tr></table></figure><h3 id="重启tomcat"><a href="#重启tomcat" class="headerlink" title="重启tomcat"></a>重启tomcat</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#重启cmdb后生效，可在部署cmdb包到tomcat之后直接重启</span></span><br><span class="line">-bash-4.2$ <span class="built_in">exit</span></span><br><span class="line">catalina.sh stop</span><br><span class="line">systemctl start tomcat</span><br></pre></td></tr></table></figure><h2 id="初始化cmdb"><a href="#初始化cmdb" class="headerlink" title="初始化cmdb"></a>初始化cmdb</h2><p>浏览器访问：<a href="http://ip:8080/cmdbuild/" target="_blank" rel="noopener">http://ip:8080/cmdbuild/</a></p><p>登录后设置数据库</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;本文对CMDBuild的安装配置进行了详细说明。 &lt;/p&gt;
    
    </summary>
    
      <category term="系统运维" scheme="http://wandouduoduo.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Cmdb" scheme="http://wandouduoduo.github.io/tags/Cmdb/"/>
    
  </entry>
  
</feed>
